// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZCHXAISVessel.proto

#ifndef PROTOBUF_ZCHXAISVessel_2eproto__INCLUDED
#define PROTOBUF_ZCHXAISVessel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace zhichenhaixin {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

class VesselInfo;
class AISDeviceData;
class AISDeviceDataList;
class AISMeet;
class AISVesselData;
class AISVesselDataList;
class VesselTrack;
class BaseStationReport;
class AidtoNavigationReport;
class AIS;
class AISList;
class AISHistoryTrackPoint;
class AISHistoryTrackList;

enum EPFD {
  UNDEFINED = 0,
  GPS = 1,
  GLONASS = 2,
  COMBINED_GPS_AND_GLONASS = 3,
  LORAN_C = 4,
  CHAYKA = 5,
  INTEGRATED_NAVIGATION_SYSTEM = 6,
  SURVEYED = 7,
  GALILEO = 8
};
bool EPFD_IsValid(int value);
const EPFD EPFD_MIN = UNDEFINED;
const EPFD EPFD_MAX = GALILEO;
const int EPFD_ARRAYSIZE = EPFD_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPFD_descriptor();
inline const ::std::string& EPFD_Name(EPFD value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPFD_descriptor(), value);
}
inline bool EPFD_Parse(
    const ::std::string& name, EPFD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPFD>(
    EPFD_descriptor(), name, value);
}
enum NAVI_STATUS {
  UNDER_WAY_USING_ENGINE = 0,
  AT_ANCHOR = 1,
  NOT_UNDER_COMMAND = 2,
  RESTRICTED_MANOEUVER = 3,
  CONSTRAINED_BY_DRAUGHT = 4,
  MOORED = 5,
  AGROUND = 6,
  ENGAGED_IN_FISHING = 7,
  UNDER_WAY_SAILING = 8,
  RESERVED_FOR_FUTURE_AMENDMENT_FOR_HSC = 9,
  RESERVED_FOR_FUTURE_AMENDMENT_FOR_WIG = 10,
  RESERVED_FOR_FUTURE_USE_1 = 11,
  RESERVED_FOR_FUTURE_USE_2 = 12,
  RESERVED_FOR_FUTURE_USE_3 = 13,
  RESERVED_FOR_FUTURE_USE_4 = 14,
  NOT_DEFINED = 15
};
bool NAVI_STATUS_IsValid(int value);
const NAVI_STATUS NAVI_STATUS_MIN = UNDER_WAY_USING_ENGINE;
const NAVI_STATUS NAVI_STATUS_MAX = NOT_DEFINED;
const int NAVI_STATUS_ARRAYSIZE = NAVI_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* NAVI_STATUS_descriptor();
inline const ::std::string& NAVI_STATUS_Name(NAVI_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    NAVI_STATUS_descriptor(), value);
}
inline bool NAVI_STATUS_Parse(
    const ::std::string& name, NAVI_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NAVI_STATUS>(
    NAVI_STATUS_descriptor(), name, value);
}
enum ATON_TYPE {
  DEFAULT = 0,
  REFERENCE_POINT = 1,
  RACON = 2,
  FIXED_STRUCTURE_OFF_SHORE = 3,
  SPARE = 4,
  LIGHT_WITHOUT_SECTORS = 5,
  LIGHT_WITH_SECTORS = 6,
  LEADING_LIGHT_FRONT = 7,
  LEADING_LIGHT_REAR = 8,
  BEACON_CARDINAL_N = 9,
  BEACON_CARDINAL_E = 10,
  BEACON_CARDINAL_S = 11,
  BEACON_CARDINAL_W = 12,
  BEACON_PORT_HAND = 13,
  BEACON_STARBOARD_HAND = 14,
  BEACON_PREFERRED_CHANNEL_PORT_HAND = 15,
  BEACON_PREFERRED_CHANNEL_STARBOARD_HAND = 16,
  BEACON_ISOLATED_DANGER = 17,
  BEACON_SAFE_WATER = 18,
  BEACON_SPECIAL_MARK = 19,
  CARDINAL_MARK_N = 20,
  CARDINAL_MARK_E = 21,
  CARDINAL_MARK_S = 22,
  CARDINAL_MARK_W = 23,
  PORT_HAND_MARK = 24,
  STARBOARD_HAND_MARK = 25,
  PREFERRED_CHANNEL_PORT_HAND = 26,
  PREFERRED_CHANNEL_STARBOARD_HAND = 27,
  ISOLATED_DANGER = 28,
  SAFE_WATER = 29,
  SPECIAL_MARK = 30,
  LIGHT_VESSEL_LANBY_RIGS = 31
};
bool ATON_TYPE_IsValid(int value);
const ATON_TYPE ATON_TYPE_MIN = DEFAULT;
const ATON_TYPE ATON_TYPE_MAX = LIGHT_VESSEL_LANBY_RIGS;
const int ATON_TYPE_ARRAYSIZE = ATON_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ATON_TYPE_descriptor();
inline const ::std::string& ATON_TYPE_Name(ATON_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ATON_TYPE_descriptor(), value);
}
inline bool ATON_TYPE_Parse(
    const ::std::string& name, ATON_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ATON_TYPE>(
    ATON_TYPE_descriptor(), name, value);
}
// ===================================================================

class VesselInfo : public ::google::protobuf::Message {
 public:
  VesselInfo();
  virtual ~VesselInfo();

  VesselInfo(const VesselInfo& from);

  inline VesselInfo& operator=(const VesselInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VesselInfo& default_instance();

  void Swap(VesselInfo* other);

  // implements Message ----------------------------------------------

  VesselInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VesselInfo& from);
  void MergeFrom(const VesselInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 mmsi = 2;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 2;
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);

  // required string shipType = 3;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  static const int kShipTypeFieldNumber = 3;
  inline const ::std::string& shiptype() const;
  inline void set_shiptype(const ::std::string& value);
  inline void set_shiptype(const char* value);
  inline void set_shiptype(const char* value, size_t size);
  inline ::std::string* mutable_shiptype();
  inline ::std::string* release_shiptype();
  inline void set_allocated_shiptype(::std::string* shiptype);

  // required int32 imo = 4;
  inline bool has_imo() const;
  inline void clear_imo();
  static const int kImoFieldNumber = 4;
  inline ::google::protobuf::int32 imo() const;
  inline void set_imo(::google::protobuf::int32 value);

  // required string callSign = 5;
  inline bool has_callsign() const;
  inline void clear_callsign();
  static const int kCallSignFieldNumber = 5;
  inline const ::std::string& callsign() const;
  inline void set_callsign(const ::std::string& value);
  inline void set_callsign(const char* value);
  inline void set_callsign(const char* value, size_t size);
  inline ::std::string* mutable_callsign();
  inline ::std::string* release_callsign();
  inline void set_allocated_callsign(::std::string* callsign);

  // required string shipName = 6;
  inline bool has_shipname() const;
  inline void clear_shipname();
  static const int kShipNameFieldNumber = 6;
  inline const ::std::string& shipname() const;
  inline void set_shipname(const ::std::string& value);
  inline void set_shipname(const char* value);
  inline void set_shipname(const char* value, size_t size);
  inline ::std::string* mutable_shipname();
  inline ::std::string* release_shipname();
  inline void set_allocated_shipname(::std::string* shipname);

  // required int32 cargoType = 7;
  inline bool has_cargotype() const;
  inline void clear_cargotype();
  static const int kCargoTypeFieldNumber = 7;
  inline ::google::protobuf::int32 cargotype() const;
  inline void set_cargotype(::google::protobuf::int32 value);

  // required string country = 8;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 8;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // required string vendorID = 9;
  inline bool has_vendorid() const;
  inline void clear_vendorid();
  static const int kVendorIDFieldNumber = 9;
  inline const ::std::string& vendorid() const;
  inline void set_vendorid(const ::std::string& value);
  inline void set_vendorid(const char* value);
  inline void set_vendorid(const char* value, size_t size);
  inline ::std::string* mutable_vendorid();
  inline ::std::string* release_vendorid();
  inline void set_allocated_vendorid(::std::string* vendorid);

  // required int32 shipLength = 10;
  inline bool has_shiplength() const;
  inline void clear_shiplength();
  static const int kShipLengthFieldNumber = 10;
  inline ::google::protobuf::int32 shiplength() const;
  inline void set_shiplength(::google::protobuf::int32 value);

  // required int32 shipWidth = 11;
  inline bool has_shipwidth() const;
  inline void clear_shipwidth();
  static const int kShipWidthFieldNumber = 11;
  inline ::google::protobuf::int32 shipwidth() const;
  inline void set_shipwidth(::google::protobuf::int32 value);

  // required int32 toBow = 12;
  inline bool has_tobow() const;
  inline void clear_tobow();
  static const int kToBowFieldNumber = 12;
  inline ::google::protobuf::int32 tobow() const;
  inline void set_tobow(::google::protobuf::int32 value);

  // required int32 toStern = 13;
  inline bool has_tostern() const;
  inline void clear_tostern();
  static const int kToSternFieldNumber = 13;
  inline ::google::protobuf::int32 tostern() const;
  inline void set_tostern(::google::protobuf::int32 value);

  // required int32 toPort = 14;
  inline bool has_toport() const;
  inline void clear_toport();
  static const int kToPortFieldNumber = 14;
  inline ::google::protobuf::int32 toport() const;
  inline void set_toport(::google::protobuf::int32 value);

  // required int32 toStarboard = 15;
  inline bool has_tostarboard() const;
  inline void clear_tostarboard();
  static const int kToStarboardFieldNumber = 15;
  inline ::google::protobuf::int32 tostarboard() const;
  inline void set_tostarboard(::google::protobuf::int32 value);

  // required .com.zhichenhaixin.proto.EPFD fixType = 16;
  inline bool has_fixtype() const;
  inline void clear_fixtype();
  static const int kFixTypeFieldNumber = 16;
  inline ::com::zhichenhaixin::proto::EPFD fixtype() const;
  inline void set_fixtype(::com::zhichenhaixin::proto::EPFD value);

  // required string eta = 17;
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 17;
  inline const ::std::string& eta() const;
  inline void set_eta(const ::std::string& value);
  inline void set_eta(const char* value);
  inline void set_eta(const char* value, size_t size);
  inline ::std::string* mutable_eta();
  inline ::std::string* release_eta();
  inline void set_allocated_eta(::std::string* eta);

  // required float draught = 18;
  inline bool has_draught() const;
  inline void clear_draught();
  static const int kDraughtFieldNumber = 18;
  inline float draught() const;
  inline void set_draught(float value);

  // required string dest = 19;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 19;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  inline void set_allocated_dest(::std::string* dest);

  // required uint64 UTC = 20;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 20;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.VesselInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_shiptype();
  inline void clear_has_shiptype();
  inline void set_has_imo();
  inline void clear_has_imo();
  inline void set_has_callsign();
  inline void clear_has_callsign();
  inline void set_has_shipname();
  inline void clear_has_shipname();
  inline void set_has_cargotype();
  inline void clear_has_cargotype();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_vendorid();
  inline void clear_has_vendorid();
  inline void set_has_shiplength();
  inline void clear_has_shiplength();
  inline void set_has_shipwidth();
  inline void clear_has_shipwidth();
  inline void set_has_tobow();
  inline void clear_has_tobow();
  inline void set_has_tostern();
  inline void clear_has_tostern();
  inline void set_has_toport();
  inline void clear_has_toport();
  inline void set_has_tostarboard();
  inline void clear_has_tostarboard();
  inline void set_has_fixtype();
  inline void clear_has_fixtype();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_draught();
  inline void clear_has_draught();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* shiptype_;
  ::google::protobuf::int32 mmsi_;
  ::google::protobuf::int32 imo_;
  ::std::string* callsign_;
  ::std::string* shipname_;
  ::std::string* country_;
  ::google::protobuf::int32 cargotype_;
  ::google::protobuf::int32 shiplength_;
  ::std::string* vendorid_;
  ::google::protobuf::int32 shipwidth_;
  ::google::protobuf::int32 tobow_;
  ::google::protobuf::int32 tostern_;
  ::google::protobuf::int32 toport_;
  ::google::protobuf::int32 tostarboard_;
  int fixtype_;
  ::std::string* eta_;
  ::std::string* dest_;
  ::google::protobuf::uint64 utc_;
  float draught_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static VesselInfo* default_instance_;
};
// -------------------------------------------------------------------

class AISDeviceData : public ::google::protobuf::Message {
 public:
  AISDeviceData();
  virtual ~AISDeviceData();

  AISDeviceData(const AISDeviceData& from);

  inline AISDeviceData& operator=(const AISDeviceData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISDeviceData& default_instance();

  void Swap(AISDeviceData* other);

  // implements Message ----------------------------------------------

  AISDeviceData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISDeviceData& from);
  void MergeFrom(const AISDeviceData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_code = 1;
  inline bool has_device_code() const;
  inline void clear_device_code();
  static const int kDeviceCodeFieldNumber = 1;
  inline const ::std::string& device_code() const;
  inline void set_device_code(const ::std::string& value);
  inline void set_device_code(const char* value);
  inline void set_device_code(const char* value, size_t size);
  inline ::std::string* mutable_device_code();
  inline ::std::string* release_device_code();
  inline void set_allocated_device_code(::std::string* device_code);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISDeviceData)
 private:
  inline void set_has_device_code();
  inline void clear_has_device_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* device_code_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISDeviceData* default_instance_;
};
// -------------------------------------------------------------------

class AISDeviceDataList : public ::google::protobuf::Message {
 public:
  AISDeviceDataList();
  virtual ~AISDeviceDataList();

  AISDeviceDataList(const AISDeviceDataList& from);

  inline AISDeviceDataList& operator=(const AISDeviceDataList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISDeviceDataList& default_instance();

  void Swap(AISDeviceDataList* other);

  // implements Message ----------------------------------------------

  AISDeviceDataList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISDeviceDataList& from);
  void MergeFrom(const AISDeviceDataList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.zhichenhaixin.proto.AISDeviceData ais_device_list = 1;
  inline int ais_device_list_size() const;
  inline void clear_ais_device_list();
  static const int kAisDeviceListFieldNumber = 1;
  inline const ::com::zhichenhaixin::proto::AISDeviceData& ais_device_list(int index) const;
  inline ::com::zhichenhaixin::proto::AISDeviceData* mutable_ais_device_list(int index);
  inline ::com::zhichenhaixin::proto::AISDeviceData* add_ais_device_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >&
      ais_device_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >*
      mutable_ais_device_list();

  // repeated .com.zhichenhaixin.proto.AISDeviceData bd_device_list = 2;
  inline int bd_device_list_size() const;
  inline void clear_bd_device_list();
  static const int kBdDeviceListFieldNumber = 2;
  inline const ::com::zhichenhaixin::proto::AISDeviceData& bd_device_list(int index) const;
  inline ::com::zhichenhaixin::proto::AISDeviceData* mutable_bd_device_list(int index);
  inline ::com::zhichenhaixin::proto::AISDeviceData* add_bd_device_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >&
      bd_device_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >*
      mutable_bd_device_list();

  // repeated .com.zhichenhaixin.proto.AISDeviceData cdma_device_list = 3;
  inline int cdma_device_list_size() const;
  inline void clear_cdma_device_list();
  static const int kCdmaDeviceListFieldNumber = 3;
  inline const ::com::zhichenhaixin::proto::AISDeviceData& cdma_device_list(int index) const;
  inline ::com::zhichenhaixin::proto::AISDeviceData* mutable_cdma_device_list(int index);
  inline ::com::zhichenhaixin::proto::AISDeviceData* add_cdma_device_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >&
      cdma_device_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >*
      mutable_cdma_device_list();

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISDeviceDataList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData > ais_device_list_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData > bd_device_list_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData > cdma_device_list_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISDeviceDataList* default_instance_;
};
// -------------------------------------------------------------------

class AISMeet : public ::google::protobuf::Message {
 public:
  AISMeet();
  virtual ~AISMeet();

  AISMeet(const AISMeet& from);

  inline AISMeet& operator=(const AISMeet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISMeet& default_instance();

  void Swap(AISMeet* other);

  // implements Message ----------------------------------------------

  AISMeet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISMeet& from);
  void MergeFrom(const AISMeet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // required double lon = 3;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 3;
  inline double lon() const;
  inline void set_lon(double value);

  // required double disrance = 4;
  inline bool has_disrance() const;
  inline void clear_disrance();
  static const int kDisranceFieldNumber = 4;
  inline double disrance() const;
  inline void set_disrance(double value);

  // required uint64 UTC = 5;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 5;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISMeet)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_disrance();
  inline void clear_has_disrance();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  double lat_;
  double lon_;
  double disrance_;
  ::google::protobuf::uint64 utc_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISMeet* default_instance_;
};
// -------------------------------------------------------------------

class AISVesselData : public ::google::protobuf::Message {
 public:
  AISVesselData();
  virtual ~AISVesselData();

  AISVesselData(const AISVesselData& from);

  inline AISVesselData& operator=(const AISVesselData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISVesselData& default_instance();

  void Swap(AISVesselData* other);

  // implements Message ----------------------------------------------

  AISVesselData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISVesselData& from);
  void MergeFrom(const AISVesselData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int64 mmsi = 2;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 2;
  inline ::google::protobuf::int64 mmsi() const;
  inline void set_mmsi(::google::protobuf::int64 value);

  // required string shiptype = 3;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  static const int kShiptypeFieldNumber = 3;
  inline const ::std::string& shiptype() const;
  inline void set_shiptype(const ::std::string& value);
  inline void set_shiptype(const char* value);
  inline void set_shiptype(const char* value, size_t size);
  inline ::std::string* mutable_shiptype();
  inline ::std::string* release_shiptype();
  inline void set_allocated_shiptype(::std::string* shiptype);

  // required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
  inline bool has_navstatus() const;
  inline void clear_navstatus();
  static const int kNavStatusFieldNumber = 4;
  inline ::com::zhichenhaixin::proto::NAVI_STATUS navstatus() const;
  inline void set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value);

  // required float rot = 5;
  inline bool has_rot() const;
  inline void clear_rot();
  static const int kRotFieldNumber = 5;
  inline float rot() const;
  inline void set_rot(float value);

  // required float sog = 6;
  inline bool has_sog() const;
  inline void clear_sog();
  static const int kSogFieldNumber = 6;
  inline float sog() const;
  inline void set_sog(float value);

  // required double lon = 7;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 7;
  inline double lon() const;
  inline void set_lon(double value);

  // required double lat = 8;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 8;
  inline double lat() const;
  inline void set_lat(double value);

  // required float cog = 9;
  inline bool has_cog() const;
  inline void clear_cog();
  static const int kCogFieldNumber = 9;
  inline float cog() const;
  inline void set_cog(float value);

  // required float heading = 10;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 10;
  inline float heading() const;
  inline void set_heading(float value);

  // optional int32 imo = 11;
  inline bool has_imo() const;
  inline void clear_imo();
  static const int kImoFieldNumber = 11;
  inline ::google::protobuf::int32 imo() const;
  inline void set_imo(::google::protobuf::int32 value);

  // optional string callSign = 12;
  inline bool has_callsign() const;
  inline void clear_callsign();
  static const int kCallSignFieldNumber = 12;
  inline const ::std::string& callsign() const;
  inline void set_callsign(const ::std::string& value);
  inline void set_callsign(const char* value);
  inline void set_callsign(const char* value, size_t size);
  inline ::std::string* mutable_callsign();
  inline ::std::string* release_callsign();
  inline void set_allocated_callsign(::std::string* callsign);

  // optional string shipName = 13;
  inline bool has_shipname() const;
  inline void clear_shipname();
  static const int kShipNameFieldNumber = 13;
  inline const ::std::string& shipname() const;
  inline void set_shipname(const ::std::string& value);
  inline void set_shipname(const char* value);
  inline void set_shipname(const char* value, size_t size);
  inline ::std::string* mutable_shipname();
  inline ::std::string* release_shipname();
  inline void set_allocated_shipname(::std::string* shipname);

  // optional int32 cargoType = 14;
  inline bool has_cargotype() const;
  inline void clear_cargotype();
  static const int kCargoTypeFieldNumber = 14;
  inline ::google::protobuf::int32 cargotype() const;
  inline void set_cargotype(::google::protobuf::int32 value);

  // optional string country = 15;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 15;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string vendorID = 16;
  inline bool has_vendorid() const;
  inline void clear_vendorid();
  static const int kVendorIDFieldNumber = 16;
  inline const ::std::string& vendorid() const;
  inline void set_vendorid(const ::std::string& value);
  inline void set_vendorid(const char* value);
  inline void set_vendorid(const char* value, size_t size);
  inline ::std::string* mutable_vendorid();
  inline ::std::string* release_vendorid();
  inline void set_allocated_vendorid(::std::string* vendorid);

  // optional double shipLength = 17;
  inline bool has_shiplength() const;
  inline void clear_shiplength();
  static const int kShipLengthFieldNumber = 17;
  inline double shiplength() const;
  inline void set_shiplength(double value);

  // optional double shipWidth = 18;
  inline bool has_shipwidth() const;
  inline void clear_shipwidth();
  static const int kShipWidthFieldNumber = 18;
  inline double shipwidth() const;
  inline void set_shipwidth(double value);

  // optional int32 toBow = 19;
  inline bool has_tobow() const;
  inline void clear_tobow();
  static const int kToBowFieldNumber = 19;
  inline ::google::protobuf::int32 tobow() const;
  inline void set_tobow(::google::protobuf::int32 value);

  // optional int32 toStern = 20;
  inline bool has_tostern() const;
  inline void clear_tostern();
  static const int kToSternFieldNumber = 20;
  inline ::google::protobuf::int32 tostern() const;
  inline void set_tostern(::google::protobuf::int32 value);

  // optional int32 toPort = 21;
  inline bool has_toport() const;
  inline void clear_toport();
  static const int kToPortFieldNumber = 21;
  inline ::google::protobuf::int32 toport() const;
  inline void set_toport(::google::protobuf::int32 value);

  // optional int32 toStarboard = 22;
  inline bool has_tostarboard() const;
  inline void clear_tostarboard();
  static const int kToStarboardFieldNumber = 22;
  inline ::google::protobuf::int32 tostarboard() const;
  inline void set_tostarboard(::google::protobuf::int32 value);

  // optional .com.zhichenhaixin.proto.EPFD fixType = 23;
  inline bool has_fixtype() const;
  inline void clear_fixtype();
  static const int kFixTypeFieldNumber = 23;
  inline ::com::zhichenhaixin::proto::EPFD fixtype() const;
  inline void set_fixtype(::com::zhichenhaixin::proto::EPFD value);

  // optional string eta = 24;
  inline bool has_eta() const;
  inline void clear_eta();
  static const int kEtaFieldNumber = 24;
  inline const ::std::string& eta() const;
  inline void set_eta(const ::std::string& value);
  inline void set_eta(const char* value);
  inline void set_eta(const char* value, size_t size);
  inline ::std::string* mutable_eta();
  inline ::std::string* release_eta();
  inline void set_allocated_eta(::std::string* eta);

  // optional float draught = 25;
  inline bool has_draught() const;
  inline void clear_draught();
  static const int kDraughtFieldNumber = 25;
  inline float draught() const;
  inline void set_draught(float value);

  // optional string dest = 26;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 26;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  inline void set_allocated_dest(::std::string* dest);

  // required uint64 UTC = 27;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 27;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // optional int32 status = 28;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 28;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int64 warn_utc = 29;
  inline bool has_warn_utc() const;
  inline void clear_warn_utc();
  static const int kWarnUtcFieldNumber = 29;
  inline ::google::protobuf::int64 warn_utc() const;
  inline void set_warn_utc(::google::protobuf::int64 value);

  // optional string warn_color = 30;
  inline bool has_warn_color() const;
  inline void clear_warn_color();
  static const int kWarnColorFieldNumber = 30;
  inline const ::std::string& warn_color() const;
  inline void set_warn_color(const ::std::string& value);
  inline void set_warn_color(const char* value);
  inline void set_warn_color(const char* value, size_t size);
  inline ::std::string* mutable_warn_color();
  inline ::std::string* release_warn_color();
  inline void set_allocated_warn_color(::std::string* warn_color);

  // optional int32 warn_status = 31;
  inline bool has_warn_status() const;
  inline void clear_warn_status();
  static const int kWarnStatusFieldNumber = 31;
  inline ::google::protobuf::int32 warn_status() const;
  inline void set_warn_status(::google::protobuf::int32 value);

  // optional int32 icon_number = 32;
  inline bool has_icon_number() const;
  inline void clear_icon_number();
  static const int kIconNumberFieldNumber = 32;
  inline ::google::protobuf::int32 icon_number() const;
  inline void set_icon_number(::google::protobuf::int32 value);

  // optional bytes icon_stream = 33;
  inline bool has_icon_stream() const;
  inline void clear_icon_stream();
  static const int kIconStreamFieldNumber = 33;
  inline const ::std::string& icon_stream() const;
  inline void set_icon_stream(const ::std::string& value);
  inline void set_icon_stream(const char* value);
  inline void set_icon_stream(const void* value, size_t size);
  inline ::std::string* mutable_icon_stream();
  inline ::std::string* release_icon_stream();
  inline void set_allocated_icon_stream(::std::string* icon_stream);

  // optional string icon_mark = 34;
  inline bool has_icon_mark() const;
  inline void clear_icon_mark();
  static const int kIconMarkFieldNumber = 34;
  inline const ::std::string& icon_mark() const;
  inline void set_icon_mark(const ::std::string& value);
  inline void set_icon_mark(const char* value);
  inline void set_icon_mark(const char* value, size_t size);
  inline ::std::string* mutable_icon_mark();
  inline ::std::string* release_icon_mark();
  inline void set_allocated_icon_mark(::std::string* icon_mark);

  // optional string cdma_phone = 35;
  inline bool has_cdma_phone() const;
  inline void clear_cdma_phone();
  static const int kCdmaPhoneFieldNumber = 35;
  inline const ::std::string& cdma_phone() const;
  inline void set_cdma_phone(const ::std::string& value);
  inline void set_cdma_phone(const char* value);
  inline void set_cdma_phone(const char* value, size_t size);
  inline ::std::string* mutable_cdma_phone();
  inline ::std::string* release_cdma_phone();
  inline void set_allocated_cdma_phone(::std::string* cdma_phone);

  // optional string bd_id = 36;
  inline bool has_bd_id() const;
  inline void clear_bd_id();
  static const int kBdIdFieldNumber = 36;
  inline const ::std::string& bd_id() const;
  inline void set_bd_id(const ::std::string& value);
  inline void set_bd_id(const char* value);
  inline void set_bd_id(const char* value, size_t size);
  inline ::std::string* mutable_bd_id();
  inline ::std::string* release_bd_id();
  inline void set_allocated_bd_id(::std::string* bd_id);

  // optional string ship_no = 37;
  inline bool has_ship_no() const;
  inline void clear_ship_no();
  static const int kShipNoFieldNumber = 37;
  inline const ::std::string& ship_no() const;
  inline void set_ship_no(const ::std::string& value);
  inline void set_ship_no(const char* value);
  inline void set_ship_no(const char* value, size_t size);
  inline ::std::string* mutable_ship_no();
  inline ::std::string* release_ship_no();
  inline void set_allocated_ship_no(::std::string* ship_no);

  // optional string dist_ship_district = 38;
  inline bool has_dist_ship_district() const;
  inline void clear_dist_ship_district();
  static const int kDistShipDistrictFieldNumber = 38;
  inline const ::std::string& dist_ship_district() const;
  inline void set_dist_ship_district(const ::std::string& value);
  inline void set_dist_ship_district(const char* value);
  inline void set_dist_ship_district(const char* value, size_t size);
  inline ::std::string* mutable_dist_ship_district();
  inline ::std::string* release_dist_ship_district();
  inline void set_allocated_dist_ship_district(::std::string* dist_ship_district);

  // optional string ship_port = 39;
  inline bool has_ship_port() const;
  inline void clear_ship_port();
  static const int kShipPortFieldNumber = 39;
  inline const ::std::string& ship_port() const;
  inline void set_ship_port(const ::std::string& value);
  inline void set_ship_port(const char* value);
  inline void set_ship_port(const char* value, size_t size);
  inline ::std::string* mutable_ship_port();
  inline ::std::string* release_ship_port();
  inline void set_allocated_ship_port(::std::string* ship_port);

  // optional double ship_deep = 40;
  inline bool has_ship_deep() const;
  inline void clear_ship_deep();
  static const int kShipDeepFieldNumber = 40;
  inline double ship_deep() const;
  inline void set_ship_deep(double value);

  // optional double ship_tot_ton = 41;
  inline bool has_ship_tot_ton() const;
  inline void clear_ship_tot_ton();
  static const int kShipTotTonFieldNumber = 41;
  inline double ship_tot_ton() const;
  inline void set_ship_tot_ton(double value);

  // optional double ship_net_ton = 42;
  inline bool has_ship_net_ton() const;
  inline void clear_ship_net_ton();
  static const int kShipNetTonFieldNumber = 42;
  inline double ship_net_ton() const;
  inline void set_ship_net_ton(double value);

  // optional double ship_tot_power = 43;
  inline bool has_ship_tot_power() const;
  inline void clear_ship_tot_power();
  static const int kShipTotPowerFieldNumber = 43;
  inline double ship_tot_power() const;
  inline void set_ship_tot_power(double value);

  // optional string dict_ship_material = 44;
  inline bool has_dict_ship_material() const;
  inline void clear_dict_ship_material();
  static const int kDictShipMaterialFieldNumber = 44;
  inline const ::std::string& dict_ship_material() const;
  inline void set_dict_ship_material(const ::std::string& value);
  inline void set_dict_ship_material(const char* value);
  inline void set_dict_ship_material(const char* value, size_t size);
  inline ::std::string* mutable_dict_ship_material();
  inline ::std::string* release_dict_ship_material();
  inline void set_allocated_dict_ship_material(::std::string* dict_ship_material);

  // optional string ship_build_comp_date = 45;
  inline bool has_ship_build_comp_date() const;
  inline void clear_ship_build_comp_date();
  static const int kShipBuildCompDateFieldNumber = 45;
  inline const ::std::string& ship_build_comp_date() const;
  inline void set_ship_build_comp_date(const ::std::string& value);
  inline void set_ship_build_comp_date(const char* value);
  inline void set_ship_build_comp_date(const char* value, size_t size);
  inline ::std::string* mutable_ship_build_comp_date();
  inline ::std::string* release_ship_build_comp_date();
  inline void set_allocated_ship_build_comp_date(::std::string* ship_build_comp_date);

  // optional string owner_name = 46;
  inline bool has_owner_name() const;
  inline void clear_owner_name();
  static const int kOwnerNameFieldNumber = 46;
  inline const ::std::string& owner_name() const;
  inline void set_owner_name(const ::std::string& value);
  inline void set_owner_name(const char* value);
  inline void set_owner_name(const char* value, size_t size);
  inline ::std::string* mutable_owner_name();
  inline ::std::string* release_owner_name();
  inline void set_allocated_owner_name(::std::string* owner_name);

  // optional string owner_addr = 47;
  inline bool has_owner_addr() const;
  inline void clear_owner_addr();
  static const int kOwnerAddrFieldNumber = 47;
  inline const ::std::string& owner_addr() const;
  inline void set_owner_addr(const ::std::string& value);
  inline void set_owner_addr(const char* value);
  inline void set_owner_addr(const char* value, size_t size);
  inline ::std::string* mutable_owner_addr();
  inline ::std::string* release_owner_addr();
  inline void set_allocated_owner_addr(::std::string* owner_addr);

  // optional string owner_tel = 48;
  inline bool has_owner_tel() const;
  inline void clear_owner_tel();
  static const int kOwnerTelFieldNumber = 48;
  inline const ::std::string& owner_tel() const;
  inline void set_owner_tel(const ::std::string& value);
  inline void set_owner_tel(const char* value);
  inline void set_owner_tel(const char* value, size_t size);
  inline ::std::string* mutable_owner_tel();
  inline ::std::string* release_owner_tel();
  inline void set_allocated_owner_tel(::std::string* owner_tel);

  // optional string fishing_permit_period_date = 49;
  inline bool has_fishing_permit_period_date() const;
  inline void clear_fishing_permit_period_date();
  static const int kFishingPermitPeriodDateFieldNumber = 49;
  inline const ::std::string& fishing_permit_period_date() const;
  inline void set_fishing_permit_period_date(const ::std::string& value);
  inline void set_fishing_permit_period_date(const char* value);
  inline void set_fishing_permit_period_date(const char* value, size_t size);
  inline ::std::string* mutable_fishing_permit_period_date();
  inline ::std::string* release_fishing_permit_period_date();
  inline void set_allocated_fishing_permit_period_date(::std::string* fishing_permit_period_date);

  // optional string fishing_permit_number = 50;
  inline bool has_fishing_permit_number() const;
  inline void clear_fishing_permit_number();
  static const int kFishingPermitNumberFieldNumber = 50;
  inline const ::std::string& fishing_permit_number() const;
  inline void set_fishing_permit_number(const ::std::string& value);
  inline void set_fishing_permit_number(const char* value);
  inline void set_fishing_permit_number(const char* value, size_t size);
  inline ::std::string* mutable_fishing_permit_number();
  inline ::std::string* release_fishing_permit_number();
  inline void set_allocated_fishing_permit_number(::std::string* fishing_permit_number);

  // optional string vessel_cert_period_date = 51;
  inline bool has_vessel_cert_period_date() const;
  inline void clear_vessel_cert_period_date();
  static const int kVesselCertPeriodDateFieldNumber = 51;
  inline const ::std::string& vessel_cert_period_date() const;
  inline void set_vessel_cert_period_date(const ::std::string& value);
  inline void set_vessel_cert_period_date(const char* value);
  inline void set_vessel_cert_period_date(const char* value, size_t size);
  inline ::std::string* mutable_vessel_cert_period_date();
  inline ::std::string* release_vessel_cert_period_date();
  inline void set_allocated_vessel_cert_period_date(::std::string* vessel_cert_period_date);

  // optional string vessel_cert_number = 52;
  inline bool has_vessel_cert_number() const;
  inline void clear_vessel_cert_number();
  static const int kVesselCertNumberFieldNumber = 52;
  inline const ::std::string& vessel_cert_number() const;
  inline void set_vessel_cert_number(const ::std::string& value);
  inline void set_vessel_cert_number(const char* value);
  inline void set_vessel_cert_number(const char* value, size_t size);
  inline ::std::string* mutable_vessel_cert_number();
  inline ::std::string* release_vessel_cert_number();
  inline void set_allocated_vessel_cert_number(::std::string* vessel_cert_number);

  // optional string register_period_date = 53;
  inline bool has_register_period_date() const;
  inline void clear_register_period_date();
  static const int kRegisterPeriodDateFieldNumber = 53;
  inline const ::std::string& register_period_date() const;
  inline void set_register_period_date(const ::std::string& value);
  inline void set_register_period_date(const char* value);
  inline void set_register_period_date(const char* value, size_t size);
  inline ::std::string* mutable_register_period_date();
  inline ::std::string* release_register_period_date();
  inline void set_allocated_register_period_date(::std::string* register_period_date);

  // optional string register_number = 54;
  inline bool has_register_number() const;
  inline void clear_register_number();
  static const int kRegisterNumberFieldNumber = 54;
  inline const ::std::string& register_number() const;
  inline void set_register_number(const ::std::string& value);
  inline void set_register_number(const char* value);
  inline void set_register_number(const char* value, size_t size);
  inline ::std::string* mutable_register_number();
  inline ::std::string* release_register_number();
  inline void set_allocated_register_number(::std::string* register_number);

  // optional string group_name = 55;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 55;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional int32 pos_type = 56;
  inline bool has_pos_type() const;
  inline void clear_pos_type();
  static const int kPosTypeFieldNumber = 56;
  inline ::google::protobuf::int32 pos_type() const;
  inline void set_pos_type(::google::protobuf::int32 value);

  // optional string vdesc = 57;
  inline bool has_vdesc() const;
  inline void clear_vdesc();
  static const int kVdescFieldNumber = 57;
  inline const ::std::string& vdesc() const;
  inline void set_vdesc(const ::std::string& value);
  inline void set_vdesc(const char* value);
  inline void set_vdesc(const char* value, size_t size);
  inline ::std::string* mutable_vdesc();
  inline ::std::string* release_vdesc();
  inline void set_allocated_vdesc(::std::string* vdesc);

  // optional int32 type = 58;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 58;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .com.zhichenhaixin.proto.AISDeviceDataList device_list = 59;
  inline bool has_device_list() const;
  inline void clear_device_list();
  static const int kDeviceListFieldNumber = 59;
  inline const ::com::zhichenhaixin::proto::AISDeviceDataList& device_list() const;
  inline ::com::zhichenhaixin::proto::AISDeviceDataList* mutable_device_list();
  inline ::com::zhichenhaixin::proto::AISDeviceDataList* release_device_list();
  inline void set_allocated_device_list(::com::zhichenhaixin::proto::AISDeviceDataList* device_list);

  // repeated .com.zhichenhaixin.proto.AISMeet pointMeet = 60;
  inline int pointmeet_size() const;
  inline void clear_pointmeet();
  static const int kPointMeetFieldNumber = 60;
  inline const ::com::zhichenhaixin::proto::AISMeet& pointmeet(int index) const;
  inline ::com::zhichenhaixin::proto::AISMeet* mutable_pointmeet(int index);
  inline ::com::zhichenhaixin::proto::AISMeet* add_pointmeet();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISMeet >&
      pointmeet() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISMeet >*
      mutable_pointmeet();

  // optional int32 onlineStatus = 61;
  inline bool has_onlinestatus() const;
  inline void clear_onlinestatus();
  static const int kOnlineStatusFieldNumber = 61;
  inline ::google::protobuf::int32 onlinestatus() const;
  inline void set_onlinestatus(::google::protobuf::int32 value);

  // optional int32 prepCount = 62;
  inline bool has_prepcount() const;
  inline void clear_prepcount();
  static const int kPrepCountFieldNumber = 62;
  inline ::google::protobuf::int32 prepcount() const;
  inline void set_prepcount(::google::protobuf::int32 value);

  // optional int64 utc_spacing = 63;
  inline bool has_utc_spacing() const;
  inline void clear_utc_spacing();
  static const int kUtcSpacingFieldNumber = 63;
  inline ::google::protobuf::int64 utc_spacing() const;
  inline void set_utc_spacing(::google::protobuf::int64 value);

  // optional int32 defenceId = 64;
  inline bool has_defenceid() const;
  inline void clear_defenceid();
  static const int kDefenceIdFieldNumber = 64;
  inline ::google::protobuf::int32 defenceid() const;
  inline void set_defenceid(::google::protobuf::int32 value);

  // optional string defenceName = 65;
  inline bool has_defencename() const;
  inline void clear_defencename();
  static const int kDefenceNameFieldNumber = 65;
  inline const ::std::string& defencename() const;
  inline void set_defencename(const ::std::string& value);
  inline void set_defencename(const char* value);
  inline void set_defencename(const char* value, size_t size);
  inline ::std::string* mutable_defencename();
  inline ::std::string* release_defencename();
  inline void set_allocated_defencename(::std::string* defencename);

  // optional int32 defenceType = 66;
  inline bool has_defencetype() const;
  inline void clear_defencetype();
  static const int kDefenceTypeFieldNumber = 66;
  inline ::google::protobuf::int32 defencetype() const;
  inline void set_defencetype(::google::protobuf::int32 value);

  // optional double last_lon = 67;
  inline bool has_last_lon() const;
  inline void clear_last_lon();
  static const int kLastLonFieldNumber = 67;
  inline double last_lon() const;
  inline void set_last_lon(double value);

  // optional double last_lat = 68;
  inline bool has_last_lat() const;
  inline void clear_last_lat();
  static const int kLastLatFieldNumber = 68;
  inline double last_lat() const;
  inline void set_last_lat(double value);

  // optional double last_cog = 69;
  inline bool has_last_cog() const;
  inline void clear_last_cog();
  static const int kLastCogFieldNumber = 69;
  inline double last_cog() const;
  inline void set_last_cog(double value);

  // optional int32 keyPointNumber = 70;
  inline bool has_keypointnumber() const;
  inline void clear_keypointnumber();
  static const int kKeyPointNumberFieldNumber = 70;
  inline ::google::protobuf::int32 keypointnumber() const;
  inline void set_keypointnumber(::google::protobuf::int32 value);

  // optional int32 mark_type = 71;
  inline bool has_mark_type() const;
  inline void clear_mark_type();
  static const int kMarkTypeFieldNumber = 71;
  inline ::google::protobuf::int32 mark_type() const;
  inline void set_mark_type(::google::protobuf::int32 value);

  // optional int32 alarmtype = 72;
  inline bool has_alarmtype() const;
  inline void clear_alarmtype();
  static const int kAlarmtypeFieldNumber = 72;
  inline ::google::protobuf::int32 alarmtype() const;
  inline void set_alarmtype(::google::protobuf::int32 value);

  // optional int32 alarmgrade = 73;
  inline bool has_alarmgrade() const;
  inline void clear_alarmgrade();
  static const int kAlarmgradeFieldNumber = 73;
  inline ::google::protobuf::int32 alarmgrade() const;
  inline void set_alarmgrade(::google::protobuf::int32 value);

  // optional double alarmvalue = 74;
  inline bool has_alarmvalue() const;
  inline void clear_alarmvalue();
  static const int kAlarmvalueFieldNumber = 74;
  inline double alarmvalue() const;
  inline void set_alarmvalue(double value);

  // optional double riskvalue = 75;
  inline bool has_riskvalue() const;
  inline void clear_riskvalue();
  static const int kRiskvalueFieldNumber = 75;
  inline double riskvalue() const;
  inline void set_riskvalue(double value);

  // optional string cpaAttr = 76;
  inline bool has_cpaattr() const;
  inline void clear_cpaattr();
  static const int kCpaAttrFieldNumber = 76;
  inline const ::std::string& cpaattr() const;
  inline void set_cpaattr(const ::std::string& value);
  inline void set_cpaattr(const char* value);
  inline void set_cpaattr(const char* value, size_t size);
  inline ::std::string* mutable_cpaattr();
  inline ::std::string* release_cpaattr();
  inline void set_allocated_cpaattr(::std::string* cpaattr);

  // optional bool ricIsSound = 77;
  inline bool has_ricissound() const;
  inline void clear_ricissound();
  static const int kRicIsSoundFieldNumber = 77;
  inline bool ricissound() const;
  inline void set_ricissound(bool value);

  // optional bool ricIsPopup = 78;
  inline bool has_ricispopup() const;
  inline void clear_ricispopup();
  static const int kRicIsPopupFieldNumber = 78;
  inline bool ricispopup() const;
  inline void set_ricispopup(bool value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISVesselData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_shiptype();
  inline void clear_has_shiptype();
  inline void set_has_navstatus();
  inline void clear_has_navstatus();
  inline void set_has_rot();
  inline void clear_has_rot();
  inline void set_has_sog();
  inline void clear_has_sog();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_cog();
  inline void clear_has_cog();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_imo();
  inline void clear_has_imo();
  inline void set_has_callsign();
  inline void clear_has_callsign();
  inline void set_has_shipname();
  inline void clear_has_shipname();
  inline void set_has_cargotype();
  inline void clear_has_cargotype();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_vendorid();
  inline void clear_has_vendorid();
  inline void set_has_shiplength();
  inline void clear_has_shiplength();
  inline void set_has_shipwidth();
  inline void clear_has_shipwidth();
  inline void set_has_tobow();
  inline void clear_has_tobow();
  inline void set_has_tostern();
  inline void clear_has_tostern();
  inline void set_has_toport();
  inline void clear_has_toport();
  inline void set_has_tostarboard();
  inline void clear_has_tostarboard();
  inline void set_has_fixtype();
  inline void clear_has_fixtype();
  inline void set_has_eta();
  inline void clear_has_eta();
  inline void set_has_draught();
  inline void clear_has_draught();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_utc();
  inline void clear_has_utc();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_warn_utc();
  inline void clear_has_warn_utc();
  inline void set_has_warn_color();
  inline void clear_has_warn_color();
  inline void set_has_warn_status();
  inline void clear_has_warn_status();
  inline void set_has_icon_number();
  inline void clear_has_icon_number();
  inline void set_has_icon_stream();
  inline void clear_has_icon_stream();
  inline void set_has_icon_mark();
  inline void clear_has_icon_mark();
  inline void set_has_cdma_phone();
  inline void clear_has_cdma_phone();
  inline void set_has_bd_id();
  inline void clear_has_bd_id();
  inline void set_has_ship_no();
  inline void clear_has_ship_no();
  inline void set_has_dist_ship_district();
  inline void clear_has_dist_ship_district();
  inline void set_has_ship_port();
  inline void clear_has_ship_port();
  inline void set_has_ship_deep();
  inline void clear_has_ship_deep();
  inline void set_has_ship_tot_ton();
  inline void clear_has_ship_tot_ton();
  inline void set_has_ship_net_ton();
  inline void clear_has_ship_net_ton();
  inline void set_has_ship_tot_power();
  inline void clear_has_ship_tot_power();
  inline void set_has_dict_ship_material();
  inline void clear_has_dict_ship_material();
  inline void set_has_ship_build_comp_date();
  inline void clear_has_ship_build_comp_date();
  inline void set_has_owner_name();
  inline void clear_has_owner_name();
  inline void set_has_owner_addr();
  inline void clear_has_owner_addr();
  inline void set_has_owner_tel();
  inline void clear_has_owner_tel();
  inline void set_has_fishing_permit_period_date();
  inline void clear_has_fishing_permit_period_date();
  inline void set_has_fishing_permit_number();
  inline void clear_has_fishing_permit_number();
  inline void set_has_vessel_cert_period_date();
  inline void clear_has_vessel_cert_period_date();
  inline void set_has_vessel_cert_number();
  inline void clear_has_vessel_cert_number();
  inline void set_has_register_period_date();
  inline void clear_has_register_period_date();
  inline void set_has_register_number();
  inline void clear_has_register_number();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_pos_type();
  inline void clear_has_pos_type();
  inline void set_has_vdesc();
  inline void clear_has_vdesc();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_device_list();
  inline void clear_has_device_list();
  inline void set_has_onlinestatus();
  inline void clear_has_onlinestatus();
  inline void set_has_prepcount();
  inline void clear_has_prepcount();
  inline void set_has_utc_spacing();
  inline void clear_has_utc_spacing();
  inline void set_has_defenceid();
  inline void clear_has_defenceid();
  inline void set_has_defencename();
  inline void clear_has_defencename();
  inline void set_has_defencetype();
  inline void clear_has_defencetype();
  inline void set_has_last_lon();
  inline void clear_has_last_lon();
  inline void set_has_last_lat();
  inline void clear_has_last_lat();
  inline void set_has_last_cog();
  inline void clear_has_last_cog();
  inline void set_has_keypointnumber();
  inline void clear_has_keypointnumber();
  inline void set_has_mark_type();
  inline void clear_has_mark_type();
  inline void set_has_alarmtype();
  inline void clear_has_alarmtype();
  inline void set_has_alarmgrade();
  inline void clear_has_alarmgrade();
  inline void set_has_alarmvalue();
  inline void clear_has_alarmvalue();
  inline void set_has_riskvalue();
  inline void clear_has_riskvalue();
  inline void set_has_cpaattr();
  inline void clear_has_cpaattr();
  inline void set_has_ricissound();
  inline void clear_has_ricissound();
  inline void set_has_ricispopup();
  inline void clear_has_ricispopup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[3];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::int64 mmsi_;
  ::std::string* shiptype_;
  int navstatus_;
  float rot_;
  double lon_;
  float sog_;
  float cog_;
  double lat_;
  float heading_;
  ::google::protobuf::int32 imo_;
  ::std::string* callsign_;
  ::std::string* shipname_;
  ::std::string* country_;
  ::std::string* vendorid_;
  ::google::protobuf::int32 cargotype_;
  ::google::protobuf::int32 tobow_;
  double shiplength_;
  double shipwidth_;
  ::google::protobuf::int32 tostern_;
  ::google::protobuf::int32 toport_;
  ::google::protobuf::int32 tostarboard_;
  int fixtype_;
  ::std::string* eta_;
  ::std::string* dest_;
  float draught_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::uint64 utc_;
  ::google::protobuf::int64 warn_utc_;
  ::std::string* warn_color_;
  ::google::protobuf::int32 warn_status_;
  ::google::protobuf::int32 icon_number_;
  ::std::string* icon_stream_;
  ::std::string* icon_mark_;
  ::std::string* cdma_phone_;
  ::std::string* bd_id_;
  ::std::string* ship_no_;
  ::std::string* dist_ship_district_;
  ::std::string* ship_port_;
  double ship_deep_;
  double ship_tot_ton_;
  double ship_net_ton_;
  double ship_tot_power_;
  ::std::string* dict_ship_material_;
  ::std::string* ship_build_comp_date_;
  ::std::string* owner_name_;
  ::std::string* owner_addr_;
  ::std::string* owner_tel_;
  ::std::string* fishing_permit_period_date_;
  ::std::string* fishing_permit_number_;
  ::std::string* vessel_cert_period_date_;
  ::std::string* vessel_cert_number_;
  ::std::string* register_period_date_;
  ::std::string* register_number_;
  ::std::string* group_name_;
  ::std::string* vdesc_;
  ::google::protobuf::int32 pos_type_;
  ::google::protobuf::int32 type_;
  ::com::zhichenhaixin::proto::AISDeviceDataList* device_list_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISMeet > pointmeet_;
  ::google::protobuf::int32 onlinestatus_;
  ::google::protobuf::int32 prepcount_;
  ::google::protobuf::int64 utc_spacing_;
  ::std::string* defencename_;
  ::google::protobuf::int32 defenceid_;
  ::google::protobuf::int32 defencetype_;
  double last_lon_;
  double last_lat_;
  double last_cog_;
  ::google::protobuf::int32 keypointnumber_;
  ::google::protobuf::int32 mark_type_;
  ::google::protobuf::int32 alarmtype_;
  ::google::protobuf::int32 alarmgrade_;
  double alarmvalue_;
  double riskvalue_;
  ::std::string* cpaattr_;
  bool ricissound_;
  bool ricispopup_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISVesselData* default_instance_;
};
// -------------------------------------------------------------------

class AISVesselDataList : public ::google::protobuf::Message {
 public:
  AISVesselDataList();
  virtual ~AISVesselDataList();

  AISVesselDataList(const AISVesselDataList& from);

  inline AISVesselDataList& operator=(const AISVesselDataList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISVesselDataList& default_instance();

  void Swap(AISVesselDataList* other);

  // implements Message ----------------------------------------------

  AISVesselDataList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISVesselDataList& from);
  void MergeFrom(const AISVesselDataList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.zhichenhaixin.proto.AISVesselData aisData = 1;
  inline int aisdata_size() const;
  inline void clear_aisdata();
  static const int kAisDataFieldNumber = 1;
  inline const ::com::zhichenhaixin::proto::AISVesselData& aisdata(int index) const;
  inline ::com::zhichenhaixin::proto::AISVesselData* mutable_aisdata(int index);
  inline ::com::zhichenhaixin::proto::AISVesselData* add_aisdata();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISVesselData >&
      aisdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISVesselData >*
      mutable_aisdata();

  // optional int32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISVesselDataList)
 private:
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISVesselData > aisdata_;
  ::google::protobuf::int32 length_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISVesselDataList* default_instance_;
};
// -------------------------------------------------------------------

class VesselTrack : public ::google::protobuf::Message {
 public:
  VesselTrack();
  virtual ~VesselTrack();

  VesselTrack(const VesselTrack& from);

  inline VesselTrack& operator=(const VesselTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VesselTrack& default_instance();

  void Swap(VesselTrack* other);

  // implements Message ----------------------------------------------

  VesselTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VesselTrack& from);
  void MergeFrom(const VesselTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 mmsi = 2;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 2;
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);

  // required string shiptype = 3;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  static const int kShiptypeFieldNumber = 3;
  inline const ::std::string& shiptype() const;
  inline void set_shiptype(const ::std::string& value);
  inline void set_shiptype(const char* value);
  inline void set_shiptype(const char* value, size_t size);
  inline ::std::string* mutable_shiptype();
  inline ::std::string* release_shiptype();
  inline void set_allocated_shiptype(::std::string* shiptype);

  // required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
  inline bool has_navstatus() const;
  inline void clear_navstatus();
  static const int kNavStatusFieldNumber = 4;
  inline ::com::zhichenhaixin::proto::NAVI_STATUS navstatus() const;
  inline void set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value);

  // required float rot = 5;
  inline bool has_rot() const;
  inline void clear_rot();
  static const int kRotFieldNumber = 5;
  inline float rot() const;
  inline void set_rot(float value);

  // required float sog = 6;
  inline bool has_sog() const;
  inline void clear_sog();
  static const int kSogFieldNumber = 6;
  inline float sog() const;
  inline void set_sog(float value);

  // required double lon = 7;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 7;
  inline double lon() const;
  inline void set_lon(double value);

  // required double lat = 8;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 8;
  inline double lat() const;
  inline void set_lat(double value);

  // required float cog = 9;
  inline bool has_cog() const;
  inline void clear_cog();
  static const int kCogFieldNumber = 9;
  inline float cog() const;
  inline void set_cog(float value);

  // required float heading = 10;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 10;
  inline float heading() const;
  inline void set_heading(float value);

  // required uint64 UTC = 11;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 11;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.VesselTrack)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_shiptype();
  inline void clear_has_shiptype();
  inline void set_has_navstatus();
  inline void clear_has_navstatus();
  inline void set_has_rot();
  inline void clear_has_rot();
  inline void set_has_sog();
  inline void clear_has_sog();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_cog();
  inline void clear_has_cog();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* shiptype_;
  ::google::protobuf::int32 mmsi_;
  int navstatus_;
  float rot_;
  float sog_;
  double lon_;
  double lat_;
  float cog_;
  float heading_;
  ::google::protobuf::uint64 utc_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static VesselTrack* default_instance_;
};
// -------------------------------------------------------------------

class BaseStationReport : public ::google::protobuf::Message {
 public:
  BaseStationReport();
  virtual ~BaseStationReport();

  BaseStationReport(const BaseStationReport& from);

  inline BaseStationReport& operator=(const BaseStationReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseStationReport& default_instance();

  void Swap(BaseStationReport* other);

  // implements Message ----------------------------------------------

  BaseStationReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseStationReport& from);
  void MergeFrom(const BaseStationReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 repeatIndicator = 2;
  inline bool has_repeatindicator() const;
  inline void clear_repeatindicator();
  static const int kRepeatIndicatorFieldNumber = 2;
  inline ::google::protobuf::int32 repeatindicator() const;
  inline void set_repeatindicator(::google::protobuf::int32 value);

  // required int32 mmsi = 3;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 3;
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);

  // required int32 year = 4;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 4;
  inline ::google::protobuf::int32 year() const;
  inline void set_year(::google::protobuf::int32 value);

  // required int32 month = 5;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 5;
  inline ::google::protobuf::int32 month() const;
  inline void set_month(::google::protobuf::int32 value);

  // required int32 day = 6;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 6;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // required int32 hour = 7;
  inline bool has_hour() const;
  inline void clear_hour();
  static const int kHourFieldNumber = 7;
  inline ::google::protobuf::int32 hour() const;
  inline void set_hour(::google::protobuf::int32 value);

  // required int32 minute = 8;
  inline bool has_minute() const;
  inline void clear_minute();
  static const int kMinuteFieldNumber = 8;
  inline ::google::protobuf::int32 minute() const;
  inline void set_minute(::google::protobuf::int32 value);

  // required int32 second = 9;
  inline bool has_second() const;
  inline void clear_second();
  static const int kSecondFieldNumber = 9;
  inline ::google::protobuf::int32 second() const;
  inline void set_second(::google::protobuf::int32 value);

  // required int32 positionAccuracy = 10;
  inline bool has_positionaccuracy() const;
  inline void clear_positionaccuracy();
  static const int kPositionAccuracyFieldNumber = 10;
  inline ::google::protobuf::int32 positionaccuracy() const;
  inline void set_positionaccuracy(::google::protobuf::int32 value);

  // required double lon = 11;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 11;
  inline double lon() const;
  inline void set_lon(double value);

  // required double lat = 12;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 12;
  inline double lat() const;
  inline void set_lat(double value);

  // required int32 fixType = 13;
  inline bool has_fixtype() const;
  inline void clear_fixtype();
  static const int kFixTypeFieldNumber = 13;
  inline ::google::protobuf::int32 fixtype() const;
  inline void set_fixtype(::google::protobuf::int32 value);

  // required uint64 UTC = 14;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 14;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.BaseStationReport)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_repeatindicator();
  inline void clear_has_repeatindicator();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_hour();
  inline void clear_has_hour();
  inline void set_has_minute();
  inline void clear_has_minute();
  inline void set_has_second();
  inline void clear_has_second();
  inline void set_has_positionaccuracy();
  inline void clear_has_positionaccuracy();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_fixtype();
  inline void clear_has_fixtype();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 repeatindicator_;
  ::google::protobuf::int32 mmsi_;
  ::google::protobuf::int32 year_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  ::google::protobuf::int32 positionaccuracy_;
  double lon_;
  double lat_;
  ::google::protobuf::uint64 utc_;
  ::google::protobuf::int32 fixtype_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static BaseStationReport* default_instance_;
};
// -------------------------------------------------------------------

class AidtoNavigationReport : public ::google::protobuf::Message {
 public:
  AidtoNavigationReport();
  virtual ~AidtoNavigationReport();

  AidtoNavigationReport(const AidtoNavigationReport& from);

  inline AidtoNavigationReport& operator=(const AidtoNavigationReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AidtoNavigationReport& default_instance();

  void Swap(AidtoNavigationReport* other);

  // implements Message ----------------------------------------------

  AidtoNavigationReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AidtoNavigationReport& from);
  void MergeFrom(const AidtoNavigationReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 repeatIndicator = 2;
  inline bool has_repeatindicator() const;
  inline void clear_repeatindicator();
  static const int kRepeatIndicatorFieldNumber = 2;
  inline ::google::protobuf::int32 repeatindicator() const;
  inline void set_repeatindicator(::google::protobuf::int32 value);

  // required int32 mmsi = 3;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 3;
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);

  // required .com.zhichenhaixin.proto.ATON_TYPE atonType = 4;
  inline bool has_atontype() const;
  inline void clear_atontype();
  static const int kAtonTypeFieldNumber = 4;
  inline ::com::zhichenhaixin::proto::ATON_TYPE atontype() const;
  inline void set_atontype(::com::zhichenhaixin::proto::ATON_TYPE value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 positionAccuracy = 6;
  inline bool has_positionaccuracy() const;
  inline void clear_positionaccuracy();
  static const int kPositionAccuracyFieldNumber = 6;
  inline ::google::protobuf::int32 positionaccuracy() const;
  inline void set_positionaccuracy(::google::protobuf::int32 value);

  // required double lon = 7;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 7;
  inline double lon() const;
  inline void set_lon(double value);

  // required double lat = 8;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 8;
  inline double lat() const;
  inline void set_lat(double value);

  // required int32 toBow = 9;
  inline bool has_tobow() const;
  inline void clear_tobow();
  static const int kToBowFieldNumber = 9;
  inline ::google::protobuf::int32 tobow() const;
  inline void set_tobow(::google::protobuf::int32 value);

  // required int32 toStern = 10;
  inline bool has_tostern() const;
  inline void clear_tostern();
  static const int kToSternFieldNumber = 10;
  inline ::google::protobuf::int32 tostern() const;
  inline void set_tostern(::google::protobuf::int32 value);

  // required int32 toPort = 11;
  inline bool has_toport() const;
  inline void clear_toport();
  static const int kToPortFieldNumber = 11;
  inline ::google::protobuf::int32 toport() const;
  inline void set_toport(::google::protobuf::int32 value);

  // required int32 toStarboard = 12;
  inline bool has_tostarboard() const;
  inline void clear_tostarboard();
  static const int kToStarboardFieldNumber = 12;
  inline ::google::protobuf::int32 tostarboard() const;
  inline void set_tostarboard(::google::protobuf::int32 value);

  // required int32 fixType = 13;
  inline bool has_fixtype() const;
  inline void clear_fixtype();
  static const int kFixTypeFieldNumber = 13;
  inline ::google::protobuf::int32 fixtype() const;
  inline void set_fixtype(::google::protobuf::int32 value);

  // required uint64 UTC = 14;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 14;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AidtoNavigationReport)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_repeatindicator();
  inline void clear_has_repeatindicator();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_atontype();
  inline void clear_has_atontype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_positionaccuracy();
  inline void clear_has_positionaccuracy();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_tobow();
  inline void clear_has_tobow();
  inline void set_has_tostern();
  inline void clear_has_tostern();
  inline void set_has_toport();
  inline void clear_has_toport();
  inline void set_has_tostarboard();
  inline void clear_has_tostarboard();
  inline void set_has_fixtype();
  inline void clear_has_fixtype();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 repeatindicator_;
  ::google::protobuf::int32 mmsi_;
  int atontype_;
  ::std::string* name_;
  double lon_;
  ::google::protobuf::int32 positionaccuracy_;
  ::google::protobuf::int32 tobow_;
  double lat_;
  ::google::protobuf::int32 tostern_;
  ::google::protobuf::int32 toport_;
  ::google::protobuf::int32 tostarboard_;
  ::google::protobuf::int32 fixtype_;
  ::google::protobuf::uint64 utc_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AidtoNavigationReport* default_instance_;
};
// -------------------------------------------------------------------

class AIS : public ::google::protobuf::Message {
 public:
  AIS();
  virtual ~AIS();

  AIS(const AIS& from);

  inline AIS& operator=(const AIS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIS& default_instance();

  void Swap(AIS* other);

  // implements Message ----------------------------------------------

  AIS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIS& from);
  void MergeFrom(const AIS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // required string sourceId = 2;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceIdFieldNumber = 2;
  inline const ::std::string& sourceid() const;
  inline void set_sourceid(const ::std::string& value);
  inline void set_sourceid(const char* value);
  inline void set_sourceid(const char* value, size_t size);
  inline ::std::string* mutable_sourceid();
  inline ::std::string* release_sourceid();
  inline void set_allocated_sourceid(::std::string* sourceid);

  // optional .com.zhichenhaixin.proto.VesselInfo vesselInfo = 3;
  inline bool has_vesselinfo() const;
  inline void clear_vesselinfo();
  static const int kVesselInfoFieldNumber = 3;
  inline const ::com::zhichenhaixin::proto::VesselInfo& vesselinfo() const;
  inline ::com::zhichenhaixin::proto::VesselInfo* mutable_vesselinfo();
  inline ::com::zhichenhaixin::proto::VesselInfo* release_vesselinfo();
  inline void set_allocated_vesselinfo(::com::zhichenhaixin::proto::VesselInfo* vesselinfo);

  // optional .com.zhichenhaixin.proto.VesselTrack vesselTrack = 4;
  inline bool has_vesseltrack() const;
  inline void clear_vesseltrack();
  static const int kVesselTrackFieldNumber = 4;
  inline const ::com::zhichenhaixin::proto::VesselTrack& vesseltrack() const;
  inline ::com::zhichenhaixin::proto::VesselTrack* mutable_vesseltrack();
  inline ::com::zhichenhaixin::proto::VesselTrack* release_vesseltrack();
  inline void set_allocated_vesseltrack(::com::zhichenhaixin::proto::VesselTrack* vesseltrack);

  // optional .com.zhichenhaixin.proto.BaseStationReport baseStationReport = 5;
  inline bool has_basestationreport() const;
  inline void clear_basestationreport();
  static const int kBaseStationReportFieldNumber = 5;
  inline const ::com::zhichenhaixin::proto::BaseStationReport& basestationreport() const;
  inline ::com::zhichenhaixin::proto::BaseStationReport* mutable_basestationreport();
  inline ::com::zhichenhaixin::proto::BaseStationReport* release_basestationreport();
  inline void set_allocated_basestationreport(::com::zhichenhaixin::proto::BaseStationReport* basestationreport);

  // optional .com.zhichenhaixin.proto.AidtoNavigationReport aidtoNavigationReport = 6;
  inline bool has_aidtonavigationreport() const;
  inline void clear_aidtonavigationreport();
  static const int kAidtoNavigationReportFieldNumber = 6;
  inline const ::com::zhichenhaixin::proto::AidtoNavigationReport& aidtonavigationreport() const;
  inline ::com::zhichenhaixin::proto::AidtoNavigationReport* mutable_aidtonavigationreport();
  inline ::com::zhichenhaixin::proto::AidtoNavigationReport* release_aidtonavigationreport();
  inline void set_allocated_aidtonavigationreport(::com::zhichenhaixin::proto::AidtoNavigationReport* aidtonavigationreport);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AIS)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_vesselinfo();
  inline void clear_has_vesselinfo();
  inline void set_has_vesseltrack();
  inline void clear_has_vesseltrack();
  inline void set_has_basestationreport();
  inline void clear_has_basestationreport();
  inline void set_has_aidtonavigationreport();
  inline void clear_has_aidtonavigationreport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sourceid_;
  ::com::zhichenhaixin::proto::VesselInfo* vesselinfo_;
  ::com::zhichenhaixin::proto::VesselTrack* vesseltrack_;
  ::com::zhichenhaixin::proto::BaseStationReport* basestationreport_;
  ::com::zhichenhaixin::proto::AidtoNavigationReport* aidtonavigationreport_;
  ::google::protobuf::int32 flag_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AIS* default_instance_;
};
// -------------------------------------------------------------------

class AISList : public ::google::protobuf::Message {
 public:
  AISList();
  virtual ~AISList();

  AISList(const AISList& from);

  inline AISList& operator=(const AISList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISList& default_instance();

  void Swap(AISList* other);

  // implements Message ----------------------------------------------

  AISList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISList& from);
  void MergeFrom(const AISList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 UTC = 1;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 1;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // repeated .com.zhichenhaixin.proto.AIS ais = 2;
  inline int ais_size() const;
  inline void clear_ais();
  static const int kAisFieldNumber = 2;
  inline const ::com::zhichenhaixin::proto::AIS& ais(int index) const;
  inline ::com::zhichenhaixin::proto::AIS* mutable_ais(int index);
  inline ::com::zhichenhaixin::proto::AIS* add_ais();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >&
      ais() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >*
      mutable_ais();

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISList)
 private:
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 utc_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS > ais_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISList* default_instance_;
};
// -------------------------------------------------------------------

class AISHistoryTrackPoint : public ::google::protobuf::Message {
 public:
  AISHistoryTrackPoint();
  virtual ~AISHistoryTrackPoint();

  AISHistoryTrackPoint(const AISHistoryTrackPoint& from);

  inline AISHistoryTrackPoint& operator=(const AISHistoryTrackPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISHistoryTrackPoint& default_instance();

  void Swap(AISHistoryTrackPoint* other);

  // implements Message ----------------------------------------------

  AISHistoryTrackPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISHistoryTrackPoint& from);
  void MergeFrom(const AISHistoryTrackPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int64 mmsi = 2;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  static const int kMmsiFieldNumber = 2;
  inline ::google::protobuf::int64 mmsi() const;
  inline void set_mmsi(::google::protobuf::int64 value);

  // required string shiptype = 3;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  static const int kShiptypeFieldNumber = 3;
  inline const ::std::string& shiptype() const;
  inline void set_shiptype(const ::std::string& value);
  inline void set_shiptype(const char* value);
  inline void set_shiptype(const char* value, size_t size);
  inline ::std::string* mutable_shiptype();
  inline ::std::string* release_shiptype();
  inline void set_allocated_shiptype(::std::string* shiptype);

  // required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
  inline bool has_navstatus() const;
  inline void clear_navstatus();
  static const int kNavStatusFieldNumber = 4;
  inline ::com::zhichenhaixin::proto::NAVI_STATUS navstatus() const;
  inline void set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value);

  // required float rot = 5;
  inline bool has_rot() const;
  inline void clear_rot();
  static const int kRotFieldNumber = 5;
  inline float rot() const;
  inline void set_rot(float value);

  // required float sog = 6;
  inline bool has_sog() const;
  inline void clear_sog();
  static const int kSogFieldNumber = 6;
  inline float sog() const;
  inline void set_sog(float value);

  // required double lon = 7;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 7;
  inline double lon() const;
  inline void set_lon(double value);

  // required double lat = 8;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 8;
  inline double lat() const;
  inline void set_lat(double value);

  // required float cog = 9;
  inline bool has_cog() const;
  inline void clear_cog();
  static const int kCogFieldNumber = 9;
  inline float cog() const;
  inline void set_cog(float value);

  // required float heading = 10;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 10;
  inline float heading() const;
  inline void set_heading(float value);

  // optional int32 cargoType = 11;
  inline bool has_cargotype() const;
  inline void clear_cargotype();
  static const int kCargoTypeFieldNumber = 11;
  inline ::google::protobuf::int32 cargotype() const;
  inline void set_cargotype(::google::protobuf::int32 value);

  // required uint64 UTC = 12;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUTCFieldNumber = 12;
  inline ::google::protobuf::uint64 utc() const;
  inline void set_utc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISHistoryTrackPoint)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mmsi();
  inline void clear_has_mmsi();
  inline void set_has_shiptype();
  inline void clear_has_shiptype();
  inline void set_has_navstatus();
  inline void clear_has_navstatus();
  inline void set_has_rot();
  inline void clear_has_rot();
  inline void set_has_sog();
  inline void clear_has_sog();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_cog();
  inline void clear_has_cog();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_cargotype();
  inline void clear_has_cargotype();
  inline void set_has_utc();
  inline void clear_has_utc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::int64 mmsi_;
  ::std::string* shiptype_;
  int navstatus_;
  float rot_;
  double lon_;
  float sog_;
  float cog_;
  double lat_;
  float heading_;
  ::google::protobuf::int32 cargotype_;
  ::google::protobuf::uint64 utc_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISHistoryTrackPoint* default_instance_;
};
// -------------------------------------------------------------------

class AISHistoryTrackList : public ::google::protobuf::Message {
 public:
  AISHistoryTrackList();
  virtual ~AISHistoryTrackList();

  AISHistoryTrackList(const AISHistoryTrackList& from);

  inline AISHistoryTrackList& operator=(const AISHistoryTrackList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AISHistoryTrackList& default_instance();

  void Swap(AISHistoryTrackList* other);

  // implements Message ----------------------------------------------

  AISHistoryTrackList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AISHistoryTrackList& from);
  void MergeFrom(const AISHistoryTrackList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.zhichenhaixin.proto.AISHistoryTrackPoint aisData = 1;
  inline int aisdata_size() const;
  inline void clear_aisdata();
  static const int kAisDataFieldNumber = 1;
  inline const ::com::zhichenhaixin::proto::AISHistoryTrackPoint& aisdata(int index) const;
  inline ::com::zhichenhaixin::proto::AISHistoryTrackPoint* mutable_aisdata(int index);
  inline ::com::zhichenhaixin::proto::AISHistoryTrackPoint* add_aisdata();
  inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISHistoryTrackPoint >&
      aisdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISHistoryTrackPoint >*
      mutable_aisdata();

  // @@protoc_insertion_point(class_scope:com.zhichenhaixin.proto.AISHistoryTrackList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISHistoryTrackPoint > aisdata_;
  friend void  protobuf_AddDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_AssignDesc_ZCHXAISVessel_2eproto();
  friend void protobuf_ShutdownFile_ZCHXAISVessel_2eproto();

  void InitAsDefaultInstance();
  static AISHistoryTrackList* default_instance_;
};
// ===================================================================


// ===================================================================

// VesselInfo

// required string id = 1;
inline bool VesselInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VesselInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VesselInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VesselInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& VesselInfo::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.id)
  return *id_;
}
inline void VesselInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.id)
}
inline void VesselInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.id)
}
inline void VesselInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.id)
}
inline ::std::string* VesselInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.id)
  return id_;
}
inline ::std::string* VesselInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.id)
}

// required int32 mmsi = 2;
inline bool VesselInfo::has_mmsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VesselInfo::set_has_mmsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VesselInfo::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VesselInfo::clear_mmsi() {
  mmsi_ = 0;
  clear_has_mmsi();
}
inline ::google::protobuf::int32 VesselInfo::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.mmsi)
  return mmsi_;
}
inline void VesselInfo::set_mmsi(::google::protobuf::int32 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.mmsi)
}

// required string shipType = 3;
inline bool VesselInfo::has_shiptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VesselInfo::set_has_shiptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VesselInfo::clear_has_shiptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VesselInfo::clear_shiptype() {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_->clear();
  }
  clear_has_shiptype();
}
inline const ::std::string& VesselInfo::shiptype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipType)
  return *shiptype_;
}
inline void VesselInfo::set_shiptype(const ::std::string& value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipType)
}
inline void VesselInfo::set_shiptype(const char* value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.shipType)
}
inline void VesselInfo::set_shiptype(const char* value, size_t size) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.shipType)
}
inline ::std::string* VesselInfo::mutable_shiptype() {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.shipType)
  return shiptype_;
}
inline ::std::string* VesselInfo::release_shiptype() {
  clear_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shiptype_;
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_shiptype(::std::string* shiptype) {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shiptype_;
  }
  if (shiptype) {
    set_has_shiptype();
    shiptype_ = shiptype;
  } else {
    clear_has_shiptype();
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.shipType)
}

// required int32 imo = 4;
inline bool VesselInfo::has_imo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VesselInfo::set_has_imo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VesselInfo::clear_has_imo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VesselInfo::clear_imo() {
  imo_ = 0;
  clear_has_imo();
}
inline ::google::protobuf::int32 VesselInfo::imo() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.imo)
  return imo_;
}
inline void VesselInfo::set_imo(::google::protobuf::int32 value) {
  set_has_imo();
  imo_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.imo)
}

// required string callSign = 5;
inline bool VesselInfo::has_callsign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VesselInfo::set_has_callsign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VesselInfo::clear_has_callsign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VesselInfo::clear_callsign() {
  if (callsign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_->clear();
  }
  clear_has_callsign();
}
inline const ::std::string& VesselInfo::callsign() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.callSign)
  return *callsign_;
}
inline void VesselInfo::set_callsign(const ::std::string& value) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.callSign)
}
inline void VesselInfo::set_callsign(const char* value) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.callSign)
}
inline void VesselInfo::set_callsign(const char* value, size_t size) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.callSign)
}
inline ::std::string* VesselInfo::mutable_callsign() {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.callSign)
  return callsign_;
}
inline ::std::string* VesselInfo::release_callsign() {
  clear_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = callsign_;
    callsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_callsign(::std::string* callsign) {
  if (callsign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete callsign_;
  }
  if (callsign) {
    set_has_callsign();
    callsign_ = callsign;
  } else {
    clear_has_callsign();
    callsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.callSign)
}

// required string shipName = 6;
inline bool VesselInfo::has_shipname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VesselInfo::set_has_shipname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VesselInfo::clear_has_shipname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VesselInfo::clear_shipname() {
  if (shipname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_->clear();
  }
  clear_has_shipname();
}
inline const ::std::string& VesselInfo::shipname() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipName)
  return *shipname_;
}
inline void VesselInfo::set_shipname(const ::std::string& value) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipName)
}
inline void VesselInfo::set_shipname(const char* value) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.shipName)
}
inline void VesselInfo::set_shipname(const char* value, size_t size) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.shipName)
}
inline ::std::string* VesselInfo::mutable_shipname() {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.shipName)
  return shipname_;
}
inline ::std::string* VesselInfo::release_shipname() {
  clear_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shipname_;
    shipname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_shipname(::std::string* shipname) {
  if (shipname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shipname_;
  }
  if (shipname) {
    set_has_shipname();
    shipname_ = shipname;
  } else {
    clear_has_shipname();
    shipname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.shipName)
}

// required int32 cargoType = 7;
inline bool VesselInfo::has_cargotype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VesselInfo::set_has_cargotype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VesselInfo::clear_has_cargotype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VesselInfo::clear_cargotype() {
  cargotype_ = 0;
  clear_has_cargotype();
}
inline ::google::protobuf::int32 VesselInfo::cargotype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.cargoType)
  return cargotype_;
}
inline void VesselInfo::set_cargotype(::google::protobuf::int32 value) {
  set_has_cargotype();
  cargotype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.cargoType)
}

// required string country = 8;
inline bool VesselInfo::has_country() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VesselInfo::set_has_country() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VesselInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VesselInfo::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& VesselInfo::country() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.country)
  return *country_;
}
inline void VesselInfo::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.country)
}
inline void VesselInfo::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.country)
}
inline void VesselInfo::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.country)
}
inline ::std::string* VesselInfo::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.country)
  return country_;
}
inline ::std::string* VesselInfo::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.country)
}

// required string vendorID = 9;
inline bool VesselInfo::has_vendorid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VesselInfo::set_has_vendorid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VesselInfo::clear_has_vendorid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VesselInfo::clear_vendorid() {
  if (vendorid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_->clear();
  }
  clear_has_vendorid();
}
inline const ::std::string& VesselInfo::vendorid() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.vendorID)
  return *vendorid_;
}
inline void VesselInfo::set_vendorid(const ::std::string& value) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.vendorID)
}
inline void VesselInfo::set_vendorid(const char* value) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.vendorID)
}
inline void VesselInfo::set_vendorid(const char* value, size_t size) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.vendorID)
}
inline ::std::string* VesselInfo::mutable_vendorid() {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.vendorID)
  return vendorid_;
}
inline ::std::string* VesselInfo::release_vendorid() {
  clear_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendorid_;
    vendorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_vendorid(::std::string* vendorid) {
  if (vendorid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendorid_;
  }
  if (vendorid) {
    set_has_vendorid();
    vendorid_ = vendorid;
  } else {
    clear_has_vendorid();
    vendorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.vendorID)
}

// required int32 shipLength = 10;
inline bool VesselInfo::has_shiplength() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VesselInfo::set_has_shiplength() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VesselInfo::clear_has_shiplength() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VesselInfo::clear_shiplength() {
  shiplength_ = 0;
  clear_has_shiplength();
}
inline ::google::protobuf::int32 VesselInfo::shiplength() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipLength)
  return shiplength_;
}
inline void VesselInfo::set_shiplength(::google::protobuf::int32 value) {
  set_has_shiplength();
  shiplength_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipLength)
}

// required int32 shipWidth = 11;
inline bool VesselInfo::has_shipwidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VesselInfo::set_has_shipwidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VesselInfo::clear_has_shipwidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VesselInfo::clear_shipwidth() {
  shipwidth_ = 0;
  clear_has_shipwidth();
}
inline ::google::protobuf::int32 VesselInfo::shipwidth() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.shipWidth)
  return shipwidth_;
}
inline void VesselInfo::set_shipwidth(::google::protobuf::int32 value) {
  set_has_shipwidth();
  shipwidth_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.shipWidth)
}

// required int32 toBow = 12;
inline bool VesselInfo::has_tobow() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VesselInfo::set_has_tobow() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VesselInfo::clear_has_tobow() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VesselInfo::clear_tobow() {
  tobow_ = 0;
  clear_has_tobow();
}
inline ::google::protobuf::int32 VesselInfo::tobow() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toBow)
  return tobow_;
}
inline void VesselInfo::set_tobow(::google::protobuf::int32 value) {
  set_has_tobow();
  tobow_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toBow)
}

// required int32 toStern = 13;
inline bool VesselInfo::has_tostern() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VesselInfo::set_has_tostern() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VesselInfo::clear_has_tostern() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VesselInfo::clear_tostern() {
  tostern_ = 0;
  clear_has_tostern();
}
inline ::google::protobuf::int32 VesselInfo::tostern() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toStern)
  return tostern_;
}
inline void VesselInfo::set_tostern(::google::protobuf::int32 value) {
  set_has_tostern();
  tostern_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toStern)
}

// required int32 toPort = 14;
inline bool VesselInfo::has_toport() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VesselInfo::set_has_toport() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VesselInfo::clear_has_toport() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VesselInfo::clear_toport() {
  toport_ = 0;
  clear_has_toport();
}
inline ::google::protobuf::int32 VesselInfo::toport() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toPort)
  return toport_;
}
inline void VesselInfo::set_toport(::google::protobuf::int32 value) {
  set_has_toport();
  toport_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toPort)
}

// required int32 toStarboard = 15;
inline bool VesselInfo::has_tostarboard() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VesselInfo::set_has_tostarboard() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VesselInfo::clear_has_tostarboard() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VesselInfo::clear_tostarboard() {
  tostarboard_ = 0;
  clear_has_tostarboard();
}
inline ::google::protobuf::int32 VesselInfo::tostarboard() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.toStarboard)
  return tostarboard_;
}
inline void VesselInfo::set_tostarboard(::google::protobuf::int32 value) {
  set_has_tostarboard();
  tostarboard_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.toStarboard)
}

// required .com.zhichenhaixin.proto.EPFD fixType = 16;
inline bool VesselInfo::has_fixtype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VesselInfo::set_has_fixtype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VesselInfo::clear_has_fixtype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VesselInfo::clear_fixtype() {
  fixtype_ = 0;
  clear_has_fixtype();
}
inline ::com::zhichenhaixin::proto::EPFD VesselInfo::fixtype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.fixType)
  return static_cast< ::com::zhichenhaixin::proto::EPFD >(fixtype_);
}
inline void VesselInfo::set_fixtype(::com::zhichenhaixin::proto::EPFD value) {
  assert(::com::zhichenhaixin::proto::EPFD_IsValid(value));
  set_has_fixtype();
  fixtype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.fixType)
}

// required string eta = 17;
inline bool VesselInfo::has_eta() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VesselInfo::set_has_eta() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VesselInfo::clear_has_eta() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VesselInfo::clear_eta() {
  if (eta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_->clear();
  }
  clear_has_eta();
}
inline const ::std::string& VesselInfo::eta() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.eta)
  return *eta_;
}
inline void VesselInfo::set_eta(const ::std::string& value) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.eta)
}
inline void VesselInfo::set_eta(const char* value) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.eta)
}
inline void VesselInfo::set_eta(const char* value, size_t size) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.eta)
}
inline ::std::string* VesselInfo::mutable_eta() {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.eta)
  return eta_;
}
inline ::std::string* VesselInfo::release_eta() {
  clear_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = eta_;
    eta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_eta(::std::string* eta) {
  if (eta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete eta_;
  }
  if (eta) {
    set_has_eta();
    eta_ = eta;
  } else {
    clear_has_eta();
    eta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.eta)
}

// required float draught = 18;
inline bool VesselInfo::has_draught() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VesselInfo::set_has_draught() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VesselInfo::clear_has_draught() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VesselInfo::clear_draught() {
  draught_ = 0;
  clear_has_draught();
}
inline float VesselInfo::draught() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.draught)
  return draught_;
}
inline void VesselInfo::set_draught(float value) {
  set_has_draught();
  draught_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.draught)
}

// required string dest = 19;
inline bool VesselInfo::has_dest() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VesselInfo::set_has_dest() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VesselInfo::clear_has_dest() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VesselInfo::clear_dest() {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& VesselInfo::dest() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.dest)
  return *dest_;
}
inline void VesselInfo::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.dest)
}
inline void VesselInfo::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselInfo.dest)
}
inline void VesselInfo::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselInfo.dest)
}
inline ::std::string* VesselInfo::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselInfo.dest)
  return dest_;
}
inline ::std::string* VesselInfo::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselInfo::set_allocated_dest(::std::string* dest) {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dest_;
  }
  if (dest) {
    set_has_dest();
    dest_ = dest;
  } else {
    clear_has_dest();
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselInfo.dest)
}

// required uint64 UTC = 20;
inline bool VesselInfo::has_utc() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VesselInfo::set_has_utc() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VesselInfo::clear_has_utc() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VesselInfo::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 VesselInfo::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselInfo.UTC)
  return utc_;
}
inline void VesselInfo::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselInfo.UTC)
}

// -------------------------------------------------------------------

// AISDeviceData

// optional string device_code = 1;
inline bool AISDeviceData::has_device_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AISDeviceData::set_has_device_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AISDeviceData::clear_has_device_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AISDeviceData::clear_device_code() {
  if (device_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_code_->clear();
  }
  clear_has_device_code();
}
inline const ::std::string& AISDeviceData::device_code() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISDeviceData.device_code)
  return *device_code_;
}
inline void AISDeviceData::set_device_code(const ::std::string& value) {
  set_has_device_code();
  if (device_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_code_ = new ::std::string;
  }
  device_code_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISDeviceData.device_code)
}
inline void AISDeviceData::set_device_code(const char* value) {
  set_has_device_code();
  if (device_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_code_ = new ::std::string;
  }
  device_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISDeviceData.device_code)
}
inline void AISDeviceData::set_device_code(const char* value, size_t size) {
  set_has_device_code();
  if (device_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_code_ = new ::std::string;
  }
  device_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISDeviceData.device_code)
}
inline ::std::string* AISDeviceData::mutable_device_code() {
  set_has_device_code();
  if (device_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISDeviceData.device_code)
  return device_code_;
}
inline ::std::string* AISDeviceData::release_device_code() {
  clear_has_device_code();
  if (device_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_code_;
    device_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISDeviceData::set_allocated_device_code(::std::string* device_code) {
  if (device_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_code_;
  }
  if (device_code) {
    set_has_device_code();
    device_code_ = device_code;
  } else {
    clear_has_device_code();
    device_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISDeviceData.device_code)
}

// -------------------------------------------------------------------

// AISDeviceDataList

// repeated .com.zhichenhaixin.proto.AISDeviceData ais_device_list = 1;
inline int AISDeviceDataList::ais_device_list_size() const {
  return ais_device_list_.size();
}
inline void AISDeviceDataList::clear_ais_device_list() {
  ais_device_list_.Clear();
}
inline const ::com::zhichenhaixin::proto::AISDeviceData& AISDeviceDataList::ais_device_list(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISDeviceDataList.ais_device_list)
  return ais_device_list_.Get(index);
}
inline ::com::zhichenhaixin::proto::AISDeviceData* AISDeviceDataList::mutable_ais_device_list(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISDeviceDataList.ais_device_list)
  return ais_device_list_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AISDeviceData* AISDeviceDataList::add_ais_device_list() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISDeviceDataList.ais_device_list)
  return ais_device_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >&
AISDeviceDataList::ais_device_list() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISDeviceDataList.ais_device_list)
  return ais_device_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >*
AISDeviceDataList::mutable_ais_device_list() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISDeviceDataList.ais_device_list)
  return &ais_device_list_;
}

// repeated .com.zhichenhaixin.proto.AISDeviceData bd_device_list = 2;
inline int AISDeviceDataList::bd_device_list_size() const {
  return bd_device_list_.size();
}
inline void AISDeviceDataList::clear_bd_device_list() {
  bd_device_list_.Clear();
}
inline const ::com::zhichenhaixin::proto::AISDeviceData& AISDeviceDataList::bd_device_list(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISDeviceDataList.bd_device_list)
  return bd_device_list_.Get(index);
}
inline ::com::zhichenhaixin::proto::AISDeviceData* AISDeviceDataList::mutable_bd_device_list(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISDeviceDataList.bd_device_list)
  return bd_device_list_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AISDeviceData* AISDeviceDataList::add_bd_device_list() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISDeviceDataList.bd_device_list)
  return bd_device_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >&
AISDeviceDataList::bd_device_list() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISDeviceDataList.bd_device_list)
  return bd_device_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >*
AISDeviceDataList::mutable_bd_device_list() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISDeviceDataList.bd_device_list)
  return &bd_device_list_;
}

// repeated .com.zhichenhaixin.proto.AISDeviceData cdma_device_list = 3;
inline int AISDeviceDataList::cdma_device_list_size() const {
  return cdma_device_list_.size();
}
inline void AISDeviceDataList::clear_cdma_device_list() {
  cdma_device_list_.Clear();
}
inline const ::com::zhichenhaixin::proto::AISDeviceData& AISDeviceDataList::cdma_device_list(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISDeviceDataList.cdma_device_list)
  return cdma_device_list_.Get(index);
}
inline ::com::zhichenhaixin::proto::AISDeviceData* AISDeviceDataList::mutable_cdma_device_list(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISDeviceDataList.cdma_device_list)
  return cdma_device_list_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AISDeviceData* AISDeviceDataList::add_cdma_device_list() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISDeviceDataList.cdma_device_list)
  return cdma_device_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >&
AISDeviceDataList::cdma_device_list() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISDeviceDataList.cdma_device_list)
  return cdma_device_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISDeviceData >*
AISDeviceDataList::mutable_cdma_device_list() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISDeviceDataList.cdma_device_list)
  return &cdma_device_list_;
}

// -------------------------------------------------------------------

// AISMeet

// required string id = 1;
inline bool AISMeet::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AISMeet::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AISMeet::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AISMeet::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AISMeet::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISMeet.id)
  return *id_;
}
inline void AISMeet::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISMeet.id)
}
inline void AISMeet::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISMeet.id)
}
inline void AISMeet::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISMeet.id)
}
inline ::std::string* AISMeet::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISMeet.id)
  return id_;
}
inline ::std::string* AISMeet::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISMeet::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISMeet.id)
}

// required double lat = 2;
inline bool AISMeet::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AISMeet::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AISMeet::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AISMeet::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double AISMeet::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISMeet.lat)
  return lat_;
}
inline void AISMeet::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISMeet.lat)
}

// required double lon = 3;
inline bool AISMeet::has_lon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AISMeet::set_has_lon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AISMeet::clear_has_lon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AISMeet::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double AISMeet::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISMeet.lon)
  return lon_;
}
inline void AISMeet::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISMeet.lon)
}

// required double disrance = 4;
inline bool AISMeet::has_disrance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AISMeet::set_has_disrance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AISMeet::clear_has_disrance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AISMeet::clear_disrance() {
  disrance_ = 0;
  clear_has_disrance();
}
inline double AISMeet::disrance() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISMeet.disrance)
  return disrance_;
}
inline void AISMeet::set_disrance(double value) {
  set_has_disrance();
  disrance_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISMeet.disrance)
}

// required uint64 UTC = 5;
inline bool AISMeet::has_utc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AISMeet::set_has_utc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AISMeet::clear_has_utc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AISMeet::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 AISMeet::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISMeet.UTC)
  return utc_;
}
inline void AISMeet::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISMeet.UTC)
}

// -------------------------------------------------------------------

// AISVesselData

// required string id = 1;
inline bool AISVesselData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AISVesselData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AISVesselData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AISVesselData::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AISVesselData::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.id)
  return *id_;
}
inline void AISVesselData::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.id)
}
inline void AISVesselData::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.id)
}
inline void AISVesselData::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.id)
}
inline ::std::string* AISVesselData::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.id)
  return id_;
}
inline ::std::string* AISVesselData::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.id)
}

// required int64 mmsi = 2;
inline bool AISVesselData::has_mmsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AISVesselData::set_has_mmsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AISVesselData::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AISVesselData::clear_mmsi() {
  mmsi_ = GOOGLE_LONGLONG(0);
  clear_has_mmsi();
}
inline ::google::protobuf::int64 AISVesselData::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.mmsi)
  return mmsi_;
}
inline void AISVesselData::set_mmsi(::google::protobuf::int64 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.mmsi)
}

// required string shiptype = 3;
inline bool AISVesselData::has_shiptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AISVesselData::set_has_shiptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AISVesselData::clear_has_shiptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AISVesselData::clear_shiptype() {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_->clear();
  }
  clear_has_shiptype();
}
inline const ::std::string& AISVesselData::shiptype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.shiptype)
  return *shiptype_;
}
inline void AISVesselData::set_shiptype(const ::std::string& value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.shiptype)
}
inline void AISVesselData::set_shiptype(const char* value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.shiptype)
}
inline void AISVesselData::set_shiptype(const char* value, size_t size) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.shiptype)
}
inline ::std::string* AISVesselData::mutable_shiptype() {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.shiptype)
  return shiptype_;
}
inline ::std::string* AISVesselData::release_shiptype() {
  clear_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shiptype_;
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_shiptype(::std::string* shiptype) {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shiptype_;
  }
  if (shiptype) {
    set_has_shiptype();
    shiptype_ = shiptype;
  } else {
    clear_has_shiptype();
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.shiptype)
}

// required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
inline bool AISVesselData::has_navstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AISVesselData::set_has_navstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AISVesselData::clear_has_navstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AISVesselData::clear_navstatus() {
  navstatus_ = 0;
  clear_has_navstatus();
}
inline ::com::zhichenhaixin::proto::NAVI_STATUS AISVesselData::navstatus() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.navStatus)
  return static_cast< ::com::zhichenhaixin::proto::NAVI_STATUS >(navstatus_);
}
inline void AISVesselData::set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value) {
  assert(::com::zhichenhaixin::proto::NAVI_STATUS_IsValid(value));
  set_has_navstatus();
  navstatus_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.navStatus)
}

// required float rot = 5;
inline bool AISVesselData::has_rot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AISVesselData::set_has_rot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AISVesselData::clear_has_rot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AISVesselData::clear_rot() {
  rot_ = 0;
  clear_has_rot();
}
inline float AISVesselData::rot() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.rot)
  return rot_;
}
inline void AISVesselData::set_rot(float value) {
  set_has_rot();
  rot_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.rot)
}

// required float sog = 6;
inline bool AISVesselData::has_sog() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AISVesselData::set_has_sog() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AISVesselData::clear_has_sog() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AISVesselData::clear_sog() {
  sog_ = 0;
  clear_has_sog();
}
inline float AISVesselData::sog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.sog)
  return sog_;
}
inline void AISVesselData::set_sog(float value) {
  set_has_sog();
  sog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.sog)
}

// required double lon = 7;
inline bool AISVesselData::has_lon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AISVesselData::set_has_lon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AISVesselData::clear_has_lon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AISVesselData::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double AISVesselData::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.lon)
  return lon_;
}
inline void AISVesselData::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.lon)
}

// required double lat = 8;
inline bool AISVesselData::has_lat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AISVesselData::set_has_lat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AISVesselData::clear_has_lat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AISVesselData::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double AISVesselData::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.lat)
  return lat_;
}
inline void AISVesselData::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.lat)
}

// required float cog = 9;
inline bool AISVesselData::has_cog() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AISVesselData::set_has_cog() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AISVesselData::clear_has_cog() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AISVesselData::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
inline float AISVesselData::cog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.cog)
  return cog_;
}
inline void AISVesselData::set_cog(float value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.cog)
}

// required float heading = 10;
inline bool AISVesselData::has_heading() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AISVesselData::set_has_heading() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AISVesselData::clear_has_heading() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AISVesselData::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float AISVesselData::heading() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.heading)
  return heading_;
}
inline void AISVesselData::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.heading)
}

// optional int32 imo = 11;
inline bool AISVesselData::has_imo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AISVesselData::set_has_imo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AISVesselData::clear_has_imo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AISVesselData::clear_imo() {
  imo_ = 0;
  clear_has_imo();
}
inline ::google::protobuf::int32 AISVesselData::imo() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.imo)
  return imo_;
}
inline void AISVesselData::set_imo(::google::protobuf::int32 value) {
  set_has_imo();
  imo_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.imo)
}

// optional string callSign = 12;
inline bool AISVesselData::has_callsign() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AISVesselData::set_has_callsign() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AISVesselData::clear_has_callsign() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AISVesselData::clear_callsign() {
  if (callsign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_->clear();
  }
  clear_has_callsign();
}
inline const ::std::string& AISVesselData::callsign() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.callSign)
  return *callsign_;
}
inline void AISVesselData::set_callsign(const ::std::string& value) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.callSign)
}
inline void AISVesselData::set_callsign(const char* value) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.callSign)
}
inline void AISVesselData::set_callsign(const char* value, size_t size) {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.callSign)
}
inline ::std::string* AISVesselData::mutable_callsign() {
  set_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    callsign_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.callSign)
  return callsign_;
}
inline ::std::string* AISVesselData::release_callsign() {
  clear_has_callsign();
  if (callsign_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = callsign_;
    callsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_callsign(::std::string* callsign) {
  if (callsign_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete callsign_;
  }
  if (callsign) {
    set_has_callsign();
    callsign_ = callsign;
  } else {
    clear_has_callsign();
    callsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.callSign)
}

// optional string shipName = 13;
inline bool AISVesselData::has_shipname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AISVesselData::set_has_shipname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AISVesselData::clear_has_shipname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AISVesselData::clear_shipname() {
  if (shipname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_->clear();
  }
  clear_has_shipname();
}
inline const ::std::string& AISVesselData::shipname() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.shipName)
  return *shipname_;
}
inline void AISVesselData::set_shipname(const ::std::string& value) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.shipName)
}
inline void AISVesselData::set_shipname(const char* value) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.shipName)
}
inline void AISVesselData::set_shipname(const char* value, size_t size) {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.shipName)
}
inline ::std::string* AISVesselData::mutable_shipname() {
  set_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.shipName)
  return shipname_;
}
inline ::std::string* AISVesselData::release_shipname() {
  clear_has_shipname();
  if (shipname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shipname_;
    shipname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_shipname(::std::string* shipname) {
  if (shipname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shipname_;
  }
  if (shipname) {
    set_has_shipname();
    shipname_ = shipname;
  } else {
    clear_has_shipname();
    shipname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.shipName)
}

// optional int32 cargoType = 14;
inline bool AISVesselData::has_cargotype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AISVesselData::set_has_cargotype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AISVesselData::clear_has_cargotype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AISVesselData::clear_cargotype() {
  cargotype_ = 0;
  clear_has_cargotype();
}
inline ::google::protobuf::int32 AISVesselData::cargotype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.cargoType)
  return cargotype_;
}
inline void AISVesselData::set_cargotype(::google::protobuf::int32 value) {
  set_has_cargotype();
  cargotype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.cargoType)
}

// optional string country = 15;
inline bool AISVesselData::has_country() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AISVesselData::set_has_country() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AISVesselData::clear_has_country() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AISVesselData::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& AISVesselData::country() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.country)
  return *country_;
}
inline void AISVesselData::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.country)
}
inline void AISVesselData::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.country)
}
inline void AISVesselData::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.country)
}
inline ::std::string* AISVesselData::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.country)
  return country_;
}
inline ::std::string* AISVesselData::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.country)
}

// optional string vendorID = 16;
inline bool AISVesselData::has_vendorid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AISVesselData::set_has_vendorid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AISVesselData::clear_has_vendorid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AISVesselData::clear_vendorid() {
  if (vendorid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_->clear();
  }
  clear_has_vendorid();
}
inline const ::std::string& AISVesselData::vendorid() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.vendorID)
  return *vendorid_;
}
inline void AISVesselData::set_vendorid(const ::std::string& value) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.vendorID)
}
inline void AISVesselData::set_vendorid(const char* value) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.vendorID)
}
inline void AISVesselData::set_vendorid(const char* value, size_t size) {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  vendorid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.vendorID)
}
inline ::std::string* AISVesselData::mutable_vendorid() {
  set_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.vendorID)
  return vendorid_;
}
inline ::std::string* AISVesselData::release_vendorid() {
  clear_has_vendorid();
  if (vendorid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendorid_;
    vendorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_vendorid(::std::string* vendorid) {
  if (vendorid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendorid_;
  }
  if (vendorid) {
    set_has_vendorid();
    vendorid_ = vendorid;
  } else {
    clear_has_vendorid();
    vendorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.vendorID)
}

// optional double shipLength = 17;
inline bool AISVesselData::has_shiplength() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AISVesselData::set_has_shiplength() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AISVesselData::clear_has_shiplength() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AISVesselData::clear_shiplength() {
  shiplength_ = 0;
  clear_has_shiplength();
}
inline double AISVesselData::shiplength() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.shipLength)
  return shiplength_;
}
inline void AISVesselData::set_shiplength(double value) {
  set_has_shiplength();
  shiplength_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.shipLength)
}

// optional double shipWidth = 18;
inline bool AISVesselData::has_shipwidth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AISVesselData::set_has_shipwidth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AISVesselData::clear_has_shipwidth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AISVesselData::clear_shipwidth() {
  shipwidth_ = 0;
  clear_has_shipwidth();
}
inline double AISVesselData::shipwidth() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.shipWidth)
  return shipwidth_;
}
inline void AISVesselData::set_shipwidth(double value) {
  set_has_shipwidth();
  shipwidth_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.shipWidth)
}

// optional int32 toBow = 19;
inline bool AISVesselData::has_tobow() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AISVesselData::set_has_tobow() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AISVesselData::clear_has_tobow() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AISVesselData::clear_tobow() {
  tobow_ = 0;
  clear_has_tobow();
}
inline ::google::protobuf::int32 AISVesselData::tobow() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.toBow)
  return tobow_;
}
inline void AISVesselData::set_tobow(::google::protobuf::int32 value) {
  set_has_tobow();
  tobow_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.toBow)
}

// optional int32 toStern = 20;
inline bool AISVesselData::has_tostern() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AISVesselData::set_has_tostern() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AISVesselData::clear_has_tostern() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AISVesselData::clear_tostern() {
  tostern_ = 0;
  clear_has_tostern();
}
inline ::google::protobuf::int32 AISVesselData::tostern() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.toStern)
  return tostern_;
}
inline void AISVesselData::set_tostern(::google::protobuf::int32 value) {
  set_has_tostern();
  tostern_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.toStern)
}

// optional int32 toPort = 21;
inline bool AISVesselData::has_toport() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AISVesselData::set_has_toport() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AISVesselData::clear_has_toport() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AISVesselData::clear_toport() {
  toport_ = 0;
  clear_has_toport();
}
inline ::google::protobuf::int32 AISVesselData::toport() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.toPort)
  return toport_;
}
inline void AISVesselData::set_toport(::google::protobuf::int32 value) {
  set_has_toport();
  toport_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.toPort)
}

// optional int32 toStarboard = 22;
inline bool AISVesselData::has_tostarboard() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AISVesselData::set_has_tostarboard() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AISVesselData::clear_has_tostarboard() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AISVesselData::clear_tostarboard() {
  tostarboard_ = 0;
  clear_has_tostarboard();
}
inline ::google::protobuf::int32 AISVesselData::tostarboard() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.toStarboard)
  return tostarboard_;
}
inline void AISVesselData::set_tostarboard(::google::protobuf::int32 value) {
  set_has_tostarboard();
  tostarboard_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.toStarboard)
}

// optional .com.zhichenhaixin.proto.EPFD fixType = 23;
inline bool AISVesselData::has_fixtype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AISVesselData::set_has_fixtype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AISVesselData::clear_has_fixtype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AISVesselData::clear_fixtype() {
  fixtype_ = 0;
  clear_has_fixtype();
}
inline ::com::zhichenhaixin::proto::EPFD AISVesselData::fixtype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.fixType)
  return static_cast< ::com::zhichenhaixin::proto::EPFD >(fixtype_);
}
inline void AISVesselData::set_fixtype(::com::zhichenhaixin::proto::EPFD value) {
  assert(::com::zhichenhaixin::proto::EPFD_IsValid(value));
  set_has_fixtype();
  fixtype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.fixType)
}

// optional string eta = 24;
inline bool AISVesselData::has_eta() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AISVesselData::set_has_eta() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AISVesselData::clear_has_eta() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AISVesselData::clear_eta() {
  if (eta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_->clear();
  }
  clear_has_eta();
}
inline const ::std::string& AISVesselData::eta() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.eta)
  return *eta_;
}
inline void AISVesselData::set_eta(const ::std::string& value) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.eta)
}
inline void AISVesselData::set_eta(const char* value) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.eta)
}
inline void AISVesselData::set_eta(const char* value, size_t size) {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  eta_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.eta)
}
inline ::std::string* AISVesselData::mutable_eta() {
  set_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eta_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.eta)
  return eta_;
}
inline ::std::string* AISVesselData::release_eta() {
  clear_has_eta();
  if (eta_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = eta_;
    eta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_eta(::std::string* eta) {
  if (eta_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete eta_;
  }
  if (eta) {
    set_has_eta();
    eta_ = eta;
  } else {
    clear_has_eta();
    eta_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.eta)
}

// optional float draught = 25;
inline bool AISVesselData::has_draught() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AISVesselData::set_has_draught() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AISVesselData::clear_has_draught() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AISVesselData::clear_draught() {
  draught_ = 0;
  clear_has_draught();
}
inline float AISVesselData::draught() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.draught)
  return draught_;
}
inline void AISVesselData::set_draught(float value) {
  set_has_draught();
  draught_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.draught)
}

// optional string dest = 26;
inline bool AISVesselData::has_dest() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AISVesselData::set_has_dest() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AISVesselData::clear_has_dest() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AISVesselData::clear_dest() {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& AISVesselData::dest() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.dest)
  return *dest_;
}
inline void AISVesselData::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.dest)
}
inline void AISVesselData::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.dest)
}
inline void AISVesselData::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.dest)
}
inline ::std::string* AISVesselData::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.dest)
  return dest_;
}
inline ::std::string* AISVesselData::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_dest(::std::string* dest) {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dest_;
  }
  if (dest) {
    set_has_dest();
    dest_ = dest;
  } else {
    clear_has_dest();
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.dest)
}

// required uint64 UTC = 27;
inline bool AISVesselData::has_utc() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AISVesselData::set_has_utc() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AISVesselData::clear_has_utc() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AISVesselData::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 AISVesselData::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.UTC)
  return utc_;
}
inline void AISVesselData::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.UTC)
}

// optional int32 status = 28;
inline bool AISVesselData::has_status() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AISVesselData::set_has_status() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AISVesselData::clear_has_status() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AISVesselData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 AISVesselData::status() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.status)
  return status_;
}
inline void AISVesselData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.status)
}

// optional int64 warn_utc = 29;
inline bool AISVesselData::has_warn_utc() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AISVesselData::set_has_warn_utc() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AISVesselData::clear_has_warn_utc() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AISVesselData::clear_warn_utc() {
  warn_utc_ = GOOGLE_LONGLONG(0);
  clear_has_warn_utc();
}
inline ::google::protobuf::int64 AISVesselData::warn_utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.warn_utc)
  return warn_utc_;
}
inline void AISVesselData::set_warn_utc(::google::protobuf::int64 value) {
  set_has_warn_utc();
  warn_utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.warn_utc)
}

// optional string warn_color = 30;
inline bool AISVesselData::has_warn_color() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AISVesselData::set_has_warn_color() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AISVesselData::clear_has_warn_color() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AISVesselData::clear_warn_color() {
  if (warn_color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    warn_color_->clear();
  }
  clear_has_warn_color();
}
inline const ::std::string& AISVesselData::warn_color() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.warn_color)
  return *warn_color_;
}
inline void AISVesselData::set_warn_color(const ::std::string& value) {
  set_has_warn_color();
  if (warn_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    warn_color_ = new ::std::string;
  }
  warn_color_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.warn_color)
}
inline void AISVesselData::set_warn_color(const char* value) {
  set_has_warn_color();
  if (warn_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    warn_color_ = new ::std::string;
  }
  warn_color_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.warn_color)
}
inline void AISVesselData::set_warn_color(const char* value, size_t size) {
  set_has_warn_color();
  if (warn_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    warn_color_ = new ::std::string;
  }
  warn_color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.warn_color)
}
inline ::std::string* AISVesselData::mutable_warn_color() {
  set_has_warn_color();
  if (warn_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    warn_color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.warn_color)
  return warn_color_;
}
inline ::std::string* AISVesselData::release_warn_color() {
  clear_has_warn_color();
  if (warn_color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = warn_color_;
    warn_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_warn_color(::std::string* warn_color) {
  if (warn_color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete warn_color_;
  }
  if (warn_color) {
    set_has_warn_color();
    warn_color_ = warn_color;
  } else {
    clear_has_warn_color();
    warn_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.warn_color)
}

// optional int32 warn_status = 31;
inline bool AISVesselData::has_warn_status() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AISVesselData::set_has_warn_status() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AISVesselData::clear_has_warn_status() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AISVesselData::clear_warn_status() {
  warn_status_ = 0;
  clear_has_warn_status();
}
inline ::google::protobuf::int32 AISVesselData::warn_status() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.warn_status)
  return warn_status_;
}
inline void AISVesselData::set_warn_status(::google::protobuf::int32 value) {
  set_has_warn_status();
  warn_status_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.warn_status)
}

// optional int32 icon_number = 32;
inline bool AISVesselData::has_icon_number() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AISVesselData::set_has_icon_number() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AISVesselData::clear_has_icon_number() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AISVesselData::clear_icon_number() {
  icon_number_ = 0;
  clear_has_icon_number();
}
inline ::google::protobuf::int32 AISVesselData::icon_number() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.icon_number)
  return icon_number_;
}
inline void AISVesselData::set_icon_number(::google::protobuf::int32 value) {
  set_has_icon_number();
  icon_number_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.icon_number)
}

// optional bytes icon_stream = 33;
inline bool AISVesselData::has_icon_stream() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AISVesselData::set_has_icon_stream() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AISVesselData::clear_has_icon_stream() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AISVesselData::clear_icon_stream() {
  if (icon_stream_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_stream_->clear();
  }
  clear_has_icon_stream();
}
inline const ::std::string& AISVesselData::icon_stream() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.icon_stream)
  return *icon_stream_;
}
inline void AISVesselData::set_icon_stream(const ::std::string& value) {
  set_has_icon_stream();
  if (icon_stream_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_stream_ = new ::std::string;
  }
  icon_stream_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.icon_stream)
}
inline void AISVesselData::set_icon_stream(const char* value) {
  set_has_icon_stream();
  if (icon_stream_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_stream_ = new ::std::string;
  }
  icon_stream_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.icon_stream)
}
inline void AISVesselData::set_icon_stream(const void* value, size_t size) {
  set_has_icon_stream();
  if (icon_stream_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_stream_ = new ::std::string;
  }
  icon_stream_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.icon_stream)
}
inline ::std::string* AISVesselData::mutable_icon_stream() {
  set_has_icon_stream();
  if (icon_stream_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_stream_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.icon_stream)
  return icon_stream_;
}
inline ::std::string* AISVesselData::release_icon_stream() {
  clear_has_icon_stream();
  if (icon_stream_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_stream_;
    icon_stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_icon_stream(::std::string* icon_stream) {
  if (icon_stream_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_stream_;
  }
  if (icon_stream) {
    set_has_icon_stream();
    icon_stream_ = icon_stream;
  } else {
    clear_has_icon_stream();
    icon_stream_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.icon_stream)
}

// optional string icon_mark = 34;
inline bool AISVesselData::has_icon_mark() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AISVesselData::set_has_icon_mark() {
  _has_bits_[1] |= 0x00000002u;
}
inline void AISVesselData::clear_has_icon_mark() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void AISVesselData::clear_icon_mark() {
  if (icon_mark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_mark_->clear();
  }
  clear_has_icon_mark();
}
inline const ::std::string& AISVesselData::icon_mark() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.icon_mark)
  return *icon_mark_;
}
inline void AISVesselData::set_icon_mark(const ::std::string& value) {
  set_has_icon_mark();
  if (icon_mark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_mark_ = new ::std::string;
  }
  icon_mark_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.icon_mark)
}
inline void AISVesselData::set_icon_mark(const char* value) {
  set_has_icon_mark();
  if (icon_mark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_mark_ = new ::std::string;
  }
  icon_mark_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.icon_mark)
}
inline void AISVesselData::set_icon_mark(const char* value, size_t size) {
  set_has_icon_mark();
  if (icon_mark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_mark_ = new ::std::string;
  }
  icon_mark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.icon_mark)
}
inline ::std::string* AISVesselData::mutable_icon_mark() {
  set_has_icon_mark();
  if (icon_mark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_mark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.icon_mark)
  return icon_mark_;
}
inline ::std::string* AISVesselData::release_icon_mark() {
  clear_has_icon_mark();
  if (icon_mark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_mark_;
    icon_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_icon_mark(::std::string* icon_mark) {
  if (icon_mark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_mark_;
  }
  if (icon_mark) {
    set_has_icon_mark();
    icon_mark_ = icon_mark;
  } else {
    clear_has_icon_mark();
    icon_mark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.icon_mark)
}

// optional string cdma_phone = 35;
inline bool AISVesselData::has_cdma_phone() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AISVesselData::set_has_cdma_phone() {
  _has_bits_[1] |= 0x00000004u;
}
inline void AISVesselData::clear_has_cdma_phone() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void AISVesselData::clear_cdma_phone() {
  if (cdma_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdma_phone_->clear();
  }
  clear_has_cdma_phone();
}
inline const ::std::string& AISVesselData::cdma_phone() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.cdma_phone)
  return *cdma_phone_;
}
inline void AISVesselData::set_cdma_phone(const ::std::string& value) {
  set_has_cdma_phone();
  if (cdma_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdma_phone_ = new ::std::string;
  }
  cdma_phone_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.cdma_phone)
}
inline void AISVesselData::set_cdma_phone(const char* value) {
  set_has_cdma_phone();
  if (cdma_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdma_phone_ = new ::std::string;
  }
  cdma_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.cdma_phone)
}
inline void AISVesselData::set_cdma_phone(const char* value, size_t size) {
  set_has_cdma_phone();
  if (cdma_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdma_phone_ = new ::std::string;
  }
  cdma_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.cdma_phone)
}
inline ::std::string* AISVesselData::mutable_cdma_phone() {
  set_has_cdma_phone();
  if (cdma_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cdma_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.cdma_phone)
  return cdma_phone_;
}
inline ::std::string* AISVesselData::release_cdma_phone() {
  clear_has_cdma_phone();
  if (cdma_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cdma_phone_;
    cdma_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_cdma_phone(::std::string* cdma_phone) {
  if (cdma_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cdma_phone_;
  }
  if (cdma_phone) {
    set_has_cdma_phone();
    cdma_phone_ = cdma_phone;
  } else {
    clear_has_cdma_phone();
    cdma_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.cdma_phone)
}

// optional string bd_id = 36;
inline bool AISVesselData::has_bd_id() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AISVesselData::set_has_bd_id() {
  _has_bits_[1] |= 0x00000008u;
}
inline void AISVesselData::clear_has_bd_id() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void AISVesselData::clear_bd_id() {
  if (bd_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bd_id_->clear();
  }
  clear_has_bd_id();
}
inline const ::std::string& AISVesselData::bd_id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.bd_id)
  return *bd_id_;
}
inline void AISVesselData::set_bd_id(const ::std::string& value) {
  set_has_bd_id();
  if (bd_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bd_id_ = new ::std::string;
  }
  bd_id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.bd_id)
}
inline void AISVesselData::set_bd_id(const char* value) {
  set_has_bd_id();
  if (bd_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bd_id_ = new ::std::string;
  }
  bd_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.bd_id)
}
inline void AISVesselData::set_bd_id(const char* value, size_t size) {
  set_has_bd_id();
  if (bd_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bd_id_ = new ::std::string;
  }
  bd_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.bd_id)
}
inline ::std::string* AISVesselData::mutable_bd_id() {
  set_has_bd_id();
  if (bd_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bd_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.bd_id)
  return bd_id_;
}
inline ::std::string* AISVesselData::release_bd_id() {
  clear_has_bd_id();
  if (bd_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bd_id_;
    bd_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_bd_id(::std::string* bd_id) {
  if (bd_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bd_id_;
  }
  if (bd_id) {
    set_has_bd_id();
    bd_id_ = bd_id;
  } else {
    clear_has_bd_id();
    bd_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.bd_id)
}

// optional string ship_no = 37;
inline bool AISVesselData::has_ship_no() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AISVesselData::set_has_ship_no() {
  _has_bits_[1] |= 0x00000010u;
}
inline void AISVesselData::clear_has_ship_no() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void AISVesselData::clear_ship_no() {
  if (ship_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_no_->clear();
  }
  clear_has_ship_no();
}
inline const ::std::string& AISVesselData::ship_no() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_no)
  return *ship_no_;
}
inline void AISVesselData::set_ship_no(const ::std::string& value) {
  set_has_ship_no();
  if (ship_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_no_ = new ::std::string;
  }
  ship_no_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_no)
}
inline void AISVesselData::set_ship_no(const char* value) {
  set_has_ship_no();
  if (ship_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_no_ = new ::std::string;
  }
  ship_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.ship_no)
}
inline void AISVesselData::set_ship_no(const char* value, size_t size) {
  set_has_ship_no();
  if (ship_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_no_ = new ::std::string;
  }
  ship_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.ship_no)
}
inline ::std::string* AISVesselData::mutable_ship_no() {
  set_has_ship_no();
  if (ship_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.ship_no)
  return ship_no_;
}
inline ::std::string* AISVesselData::release_ship_no() {
  clear_has_ship_no();
  if (ship_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ship_no_;
    ship_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_ship_no(::std::string* ship_no) {
  if (ship_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ship_no_;
  }
  if (ship_no) {
    set_has_ship_no();
    ship_no_ = ship_no;
  } else {
    clear_has_ship_no();
    ship_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.ship_no)
}

// optional string dist_ship_district = 38;
inline bool AISVesselData::has_dist_ship_district() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AISVesselData::set_has_dist_ship_district() {
  _has_bits_[1] |= 0x00000020u;
}
inline void AISVesselData::clear_has_dist_ship_district() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void AISVesselData::clear_dist_ship_district() {
  if (dist_ship_district_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dist_ship_district_->clear();
  }
  clear_has_dist_ship_district();
}
inline const ::std::string& AISVesselData::dist_ship_district() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.dist_ship_district)
  return *dist_ship_district_;
}
inline void AISVesselData::set_dist_ship_district(const ::std::string& value) {
  set_has_dist_ship_district();
  if (dist_ship_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dist_ship_district_ = new ::std::string;
  }
  dist_ship_district_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.dist_ship_district)
}
inline void AISVesselData::set_dist_ship_district(const char* value) {
  set_has_dist_ship_district();
  if (dist_ship_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dist_ship_district_ = new ::std::string;
  }
  dist_ship_district_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.dist_ship_district)
}
inline void AISVesselData::set_dist_ship_district(const char* value, size_t size) {
  set_has_dist_ship_district();
  if (dist_ship_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dist_ship_district_ = new ::std::string;
  }
  dist_ship_district_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.dist_ship_district)
}
inline ::std::string* AISVesselData::mutable_dist_ship_district() {
  set_has_dist_ship_district();
  if (dist_ship_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dist_ship_district_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.dist_ship_district)
  return dist_ship_district_;
}
inline ::std::string* AISVesselData::release_dist_ship_district() {
  clear_has_dist_ship_district();
  if (dist_ship_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dist_ship_district_;
    dist_ship_district_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_dist_ship_district(::std::string* dist_ship_district) {
  if (dist_ship_district_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dist_ship_district_;
  }
  if (dist_ship_district) {
    set_has_dist_ship_district();
    dist_ship_district_ = dist_ship_district;
  } else {
    clear_has_dist_ship_district();
    dist_ship_district_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.dist_ship_district)
}

// optional string ship_port = 39;
inline bool AISVesselData::has_ship_port() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void AISVesselData::set_has_ship_port() {
  _has_bits_[1] |= 0x00000040u;
}
inline void AISVesselData::clear_has_ship_port() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void AISVesselData::clear_ship_port() {
  if (ship_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_port_->clear();
  }
  clear_has_ship_port();
}
inline const ::std::string& AISVesselData::ship_port() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_port)
  return *ship_port_;
}
inline void AISVesselData::set_ship_port(const ::std::string& value) {
  set_has_ship_port();
  if (ship_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_port_ = new ::std::string;
  }
  ship_port_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_port)
}
inline void AISVesselData::set_ship_port(const char* value) {
  set_has_ship_port();
  if (ship_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_port_ = new ::std::string;
  }
  ship_port_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.ship_port)
}
inline void AISVesselData::set_ship_port(const char* value, size_t size) {
  set_has_ship_port();
  if (ship_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_port_ = new ::std::string;
  }
  ship_port_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.ship_port)
}
inline ::std::string* AISVesselData::mutable_ship_port() {
  set_has_ship_port();
  if (ship_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_port_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.ship_port)
  return ship_port_;
}
inline ::std::string* AISVesselData::release_ship_port() {
  clear_has_ship_port();
  if (ship_port_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ship_port_;
    ship_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_ship_port(::std::string* ship_port) {
  if (ship_port_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ship_port_;
  }
  if (ship_port) {
    set_has_ship_port();
    ship_port_ = ship_port;
  } else {
    clear_has_ship_port();
    ship_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.ship_port)
}

// optional double ship_deep = 40;
inline bool AISVesselData::has_ship_deep() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void AISVesselData::set_has_ship_deep() {
  _has_bits_[1] |= 0x00000080u;
}
inline void AISVesselData::clear_has_ship_deep() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void AISVesselData::clear_ship_deep() {
  ship_deep_ = 0;
  clear_has_ship_deep();
}
inline double AISVesselData::ship_deep() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_deep)
  return ship_deep_;
}
inline void AISVesselData::set_ship_deep(double value) {
  set_has_ship_deep();
  ship_deep_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_deep)
}

// optional double ship_tot_ton = 41;
inline bool AISVesselData::has_ship_tot_ton() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void AISVesselData::set_has_ship_tot_ton() {
  _has_bits_[1] |= 0x00000100u;
}
inline void AISVesselData::clear_has_ship_tot_ton() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void AISVesselData::clear_ship_tot_ton() {
  ship_tot_ton_ = 0;
  clear_has_ship_tot_ton();
}
inline double AISVesselData::ship_tot_ton() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_tot_ton)
  return ship_tot_ton_;
}
inline void AISVesselData::set_ship_tot_ton(double value) {
  set_has_ship_tot_ton();
  ship_tot_ton_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_tot_ton)
}

// optional double ship_net_ton = 42;
inline bool AISVesselData::has_ship_net_ton() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void AISVesselData::set_has_ship_net_ton() {
  _has_bits_[1] |= 0x00000200u;
}
inline void AISVesselData::clear_has_ship_net_ton() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void AISVesselData::clear_ship_net_ton() {
  ship_net_ton_ = 0;
  clear_has_ship_net_ton();
}
inline double AISVesselData::ship_net_ton() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_net_ton)
  return ship_net_ton_;
}
inline void AISVesselData::set_ship_net_ton(double value) {
  set_has_ship_net_ton();
  ship_net_ton_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_net_ton)
}

// optional double ship_tot_power = 43;
inline bool AISVesselData::has_ship_tot_power() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void AISVesselData::set_has_ship_tot_power() {
  _has_bits_[1] |= 0x00000400u;
}
inline void AISVesselData::clear_has_ship_tot_power() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void AISVesselData::clear_ship_tot_power() {
  ship_tot_power_ = 0;
  clear_has_ship_tot_power();
}
inline double AISVesselData::ship_tot_power() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_tot_power)
  return ship_tot_power_;
}
inline void AISVesselData::set_ship_tot_power(double value) {
  set_has_ship_tot_power();
  ship_tot_power_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_tot_power)
}

// optional string dict_ship_material = 44;
inline bool AISVesselData::has_dict_ship_material() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void AISVesselData::set_has_dict_ship_material() {
  _has_bits_[1] |= 0x00000800u;
}
inline void AISVesselData::clear_has_dict_ship_material() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void AISVesselData::clear_dict_ship_material() {
  if (dict_ship_material_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dict_ship_material_->clear();
  }
  clear_has_dict_ship_material();
}
inline const ::std::string& AISVesselData::dict_ship_material() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.dict_ship_material)
  return *dict_ship_material_;
}
inline void AISVesselData::set_dict_ship_material(const ::std::string& value) {
  set_has_dict_ship_material();
  if (dict_ship_material_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dict_ship_material_ = new ::std::string;
  }
  dict_ship_material_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.dict_ship_material)
}
inline void AISVesselData::set_dict_ship_material(const char* value) {
  set_has_dict_ship_material();
  if (dict_ship_material_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dict_ship_material_ = new ::std::string;
  }
  dict_ship_material_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.dict_ship_material)
}
inline void AISVesselData::set_dict_ship_material(const char* value, size_t size) {
  set_has_dict_ship_material();
  if (dict_ship_material_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dict_ship_material_ = new ::std::string;
  }
  dict_ship_material_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.dict_ship_material)
}
inline ::std::string* AISVesselData::mutable_dict_ship_material() {
  set_has_dict_ship_material();
  if (dict_ship_material_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dict_ship_material_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.dict_ship_material)
  return dict_ship_material_;
}
inline ::std::string* AISVesselData::release_dict_ship_material() {
  clear_has_dict_ship_material();
  if (dict_ship_material_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dict_ship_material_;
    dict_ship_material_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_dict_ship_material(::std::string* dict_ship_material) {
  if (dict_ship_material_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dict_ship_material_;
  }
  if (dict_ship_material) {
    set_has_dict_ship_material();
    dict_ship_material_ = dict_ship_material;
  } else {
    clear_has_dict_ship_material();
    dict_ship_material_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.dict_ship_material)
}

// optional string ship_build_comp_date = 45;
inline bool AISVesselData::has_ship_build_comp_date() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void AISVesselData::set_has_ship_build_comp_date() {
  _has_bits_[1] |= 0x00001000u;
}
inline void AISVesselData::clear_has_ship_build_comp_date() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void AISVesselData::clear_ship_build_comp_date() {
  if (ship_build_comp_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_build_comp_date_->clear();
  }
  clear_has_ship_build_comp_date();
}
inline const ::std::string& AISVesselData::ship_build_comp_date() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ship_build_comp_date)
  return *ship_build_comp_date_;
}
inline void AISVesselData::set_ship_build_comp_date(const ::std::string& value) {
  set_has_ship_build_comp_date();
  if (ship_build_comp_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_build_comp_date_ = new ::std::string;
  }
  ship_build_comp_date_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ship_build_comp_date)
}
inline void AISVesselData::set_ship_build_comp_date(const char* value) {
  set_has_ship_build_comp_date();
  if (ship_build_comp_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_build_comp_date_ = new ::std::string;
  }
  ship_build_comp_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.ship_build_comp_date)
}
inline void AISVesselData::set_ship_build_comp_date(const char* value, size_t size) {
  set_has_ship_build_comp_date();
  if (ship_build_comp_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_build_comp_date_ = new ::std::string;
  }
  ship_build_comp_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.ship_build_comp_date)
}
inline ::std::string* AISVesselData::mutable_ship_build_comp_date() {
  set_has_ship_build_comp_date();
  if (ship_build_comp_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ship_build_comp_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.ship_build_comp_date)
  return ship_build_comp_date_;
}
inline ::std::string* AISVesselData::release_ship_build_comp_date() {
  clear_has_ship_build_comp_date();
  if (ship_build_comp_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ship_build_comp_date_;
    ship_build_comp_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_ship_build_comp_date(::std::string* ship_build_comp_date) {
  if (ship_build_comp_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ship_build_comp_date_;
  }
  if (ship_build_comp_date) {
    set_has_ship_build_comp_date();
    ship_build_comp_date_ = ship_build_comp_date;
  } else {
    clear_has_ship_build_comp_date();
    ship_build_comp_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.ship_build_comp_date)
}

// optional string owner_name = 46;
inline bool AISVesselData::has_owner_name() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void AISVesselData::set_has_owner_name() {
  _has_bits_[1] |= 0x00002000u;
}
inline void AISVesselData::clear_has_owner_name() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void AISVesselData::clear_owner_name() {
  if (owner_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_->clear();
  }
  clear_has_owner_name();
}
inline const ::std::string& AISVesselData::owner_name() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.owner_name)
  return *owner_name_;
}
inline void AISVesselData::set_owner_name(const ::std::string& value) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.owner_name)
}
inline void AISVesselData::set_owner_name(const char* value) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.owner_name)
}
inline void AISVesselData::set_owner_name(const char* value, size_t size) {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  owner_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.owner_name)
}
inline ::std::string* AISVesselData::mutable_owner_name() {
  set_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.owner_name)
  return owner_name_;
}
inline ::std::string* AISVesselData::release_owner_name() {
  clear_has_owner_name();
  if (owner_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = owner_name_;
    owner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_owner_name(::std::string* owner_name) {
  if (owner_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_name_;
  }
  if (owner_name) {
    set_has_owner_name();
    owner_name_ = owner_name;
  } else {
    clear_has_owner_name();
    owner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.owner_name)
}

// optional string owner_addr = 47;
inline bool AISVesselData::has_owner_addr() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void AISVesselData::set_has_owner_addr() {
  _has_bits_[1] |= 0x00004000u;
}
inline void AISVesselData::clear_has_owner_addr() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void AISVesselData::clear_owner_addr() {
  if (owner_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_addr_->clear();
  }
  clear_has_owner_addr();
}
inline const ::std::string& AISVesselData::owner_addr() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.owner_addr)
  return *owner_addr_;
}
inline void AISVesselData::set_owner_addr(const ::std::string& value) {
  set_has_owner_addr();
  if (owner_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_addr_ = new ::std::string;
  }
  owner_addr_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.owner_addr)
}
inline void AISVesselData::set_owner_addr(const char* value) {
  set_has_owner_addr();
  if (owner_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_addr_ = new ::std::string;
  }
  owner_addr_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.owner_addr)
}
inline void AISVesselData::set_owner_addr(const char* value, size_t size) {
  set_has_owner_addr();
  if (owner_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_addr_ = new ::std::string;
  }
  owner_addr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.owner_addr)
}
inline ::std::string* AISVesselData::mutable_owner_addr() {
  set_has_owner_addr();
  if (owner_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_addr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.owner_addr)
  return owner_addr_;
}
inline ::std::string* AISVesselData::release_owner_addr() {
  clear_has_owner_addr();
  if (owner_addr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = owner_addr_;
    owner_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_owner_addr(::std::string* owner_addr) {
  if (owner_addr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_addr_;
  }
  if (owner_addr) {
    set_has_owner_addr();
    owner_addr_ = owner_addr;
  } else {
    clear_has_owner_addr();
    owner_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.owner_addr)
}

// optional string owner_tel = 48;
inline bool AISVesselData::has_owner_tel() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void AISVesselData::set_has_owner_tel() {
  _has_bits_[1] |= 0x00008000u;
}
inline void AISVesselData::clear_has_owner_tel() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void AISVesselData::clear_owner_tel() {
  if (owner_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_tel_->clear();
  }
  clear_has_owner_tel();
}
inline const ::std::string& AISVesselData::owner_tel() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.owner_tel)
  return *owner_tel_;
}
inline void AISVesselData::set_owner_tel(const ::std::string& value) {
  set_has_owner_tel();
  if (owner_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_tel_ = new ::std::string;
  }
  owner_tel_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.owner_tel)
}
inline void AISVesselData::set_owner_tel(const char* value) {
  set_has_owner_tel();
  if (owner_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_tel_ = new ::std::string;
  }
  owner_tel_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.owner_tel)
}
inline void AISVesselData::set_owner_tel(const char* value, size_t size) {
  set_has_owner_tel();
  if (owner_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_tel_ = new ::std::string;
  }
  owner_tel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.owner_tel)
}
inline ::std::string* AISVesselData::mutable_owner_tel() {
  set_has_owner_tel();
  if (owner_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_tel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.owner_tel)
  return owner_tel_;
}
inline ::std::string* AISVesselData::release_owner_tel() {
  clear_has_owner_tel();
  if (owner_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = owner_tel_;
    owner_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_owner_tel(::std::string* owner_tel) {
  if (owner_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_tel_;
  }
  if (owner_tel) {
    set_has_owner_tel();
    owner_tel_ = owner_tel;
  } else {
    clear_has_owner_tel();
    owner_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.owner_tel)
}

// optional string fishing_permit_period_date = 49;
inline bool AISVesselData::has_fishing_permit_period_date() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void AISVesselData::set_has_fishing_permit_period_date() {
  _has_bits_[1] |= 0x00010000u;
}
inline void AISVesselData::clear_has_fishing_permit_period_date() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void AISVesselData::clear_fishing_permit_period_date() {
  if (fishing_permit_period_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_period_date_->clear();
  }
  clear_has_fishing_permit_period_date();
}
inline const ::std::string& AISVesselData::fishing_permit_period_date() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.fishing_permit_period_date)
  return *fishing_permit_period_date_;
}
inline void AISVesselData::set_fishing_permit_period_date(const ::std::string& value) {
  set_has_fishing_permit_period_date();
  if (fishing_permit_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_period_date_ = new ::std::string;
  }
  fishing_permit_period_date_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.fishing_permit_period_date)
}
inline void AISVesselData::set_fishing_permit_period_date(const char* value) {
  set_has_fishing_permit_period_date();
  if (fishing_permit_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_period_date_ = new ::std::string;
  }
  fishing_permit_period_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.fishing_permit_period_date)
}
inline void AISVesselData::set_fishing_permit_period_date(const char* value, size_t size) {
  set_has_fishing_permit_period_date();
  if (fishing_permit_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_period_date_ = new ::std::string;
  }
  fishing_permit_period_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.fishing_permit_period_date)
}
inline ::std::string* AISVesselData::mutable_fishing_permit_period_date() {
  set_has_fishing_permit_period_date();
  if (fishing_permit_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_period_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.fishing_permit_period_date)
  return fishing_permit_period_date_;
}
inline ::std::string* AISVesselData::release_fishing_permit_period_date() {
  clear_has_fishing_permit_period_date();
  if (fishing_permit_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fishing_permit_period_date_;
    fishing_permit_period_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_fishing_permit_period_date(::std::string* fishing_permit_period_date) {
  if (fishing_permit_period_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fishing_permit_period_date_;
  }
  if (fishing_permit_period_date) {
    set_has_fishing_permit_period_date();
    fishing_permit_period_date_ = fishing_permit_period_date;
  } else {
    clear_has_fishing_permit_period_date();
    fishing_permit_period_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.fishing_permit_period_date)
}

// optional string fishing_permit_number = 50;
inline bool AISVesselData::has_fishing_permit_number() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void AISVesselData::set_has_fishing_permit_number() {
  _has_bits_[1] |= 0x00020000u;
}
inline void AISVesselData::clear_has_fishing_permit_number() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void AISVesselData::clear_fishing_permit_number() {
  if (fishing_permit_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_number_->clear();
  }
  clear_has_fishing_permit_number();
}
inline const ::std::string& AISVesselData::fishing_permit_number() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.fishing_permit_number)
  return *fishing_permit_number_;
}
inline void AISVesselData::set_fishing_permit_number(const ::std::string& value) {
  set_has_fishing_permit_number();
  if (fishing_permit_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_number_ = new ::std::string;
  }
  fishing_permit_number_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.fishing_permit_number)
}
inline void AISVesselData::set_fishing_permit_number(const char* value) {
  set_has_fishing_permit_number();
  if (fishing_permit_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_number_ = new ::std::string;
  }
  fishing_permit_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.fishing_permit_number)
}
inline void AISVesselData::set_fishing_permit_number(const char* value, size_t size) {
  set_has_fishing_permit_number();
  if (fishing_permit_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_number_ = new ::std::string;
  }
  fishing_permit_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.fishing_permit_number)
}
inline ::std::string* AISVesselData::mutable_fishing_permit_number() {
  set_has_fishing_permit_number();
  if (fishing_permit_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fishing_permit_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.fishing_permit_number)
  return fishing_permit_number_;
}
inline ::std::string* AISVesselData::release_fishing_permit_number() {
  clear_has_fishing_permit_number();
  if (fishing_permit_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fishing_permit_number_;
    fishing_permit_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_fishing_permit_number(::std::string* fishing_permit_number) {
  if (fishing_permit_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fishing_permit_number_;
  }
  if (fishing_permit_number) {
    set_has_fishing_permit_number();
    fishing_permit_number_ = fishing_permit_number;
  } else {
    clear_has_fishing_permit_number();
    fishing_permit_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.fishing_permit_number)
}

// optional string vessel_cert_period_date = 51;
inline bool AISVesselData::has_vessel_cert_period_date() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void AISVesselData::set_has_vessel_cert_period_date() {
  _has_bits_[1] |= 0x00040000u;
}
inline void AISVesselData::clear_has_vessel_cert_period_date() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void AISVesselData::clear_vessel_cert_period_date() {
  if (vessel_cert_period_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_period_date_->clear();
  }
  clear_has_vessel_cert_period_date();
}
inline const ::std::string& AISVesselData::vessel_cert_period_date() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.vessel_cert_period_date)
  return *vessel_cert_period_date_;
}
inline void AISVesselData::set_vessel_cert_period_date(const ::std::string& value) {
  set_has_vessel_cert_period_date();
  if (vessel_cert_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_period_date_ = new ::std::string;
  }
  vessel_cert_period_date_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.vessel_cert_period_date)
}
inline void AISVesselData::set_vessel_cert_period_date(const char* value) {
  set_has_vessel_cert_period_date();
  if (vessel_cert_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_period_date_ = new ::std::string;
  }
  vessel_cert_period_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.vessel_cert_period_date)
}
inline void AISVesselData::set_vessel_cert_period_date(const char* value, size_t size) {
  set_has_vessel_cert_period_date();
  if (vessel_cert_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_period_date_ = new ::std::string;
  }
  vessel_cert_period_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.vessel_cert_period_date)
}
inline ::std::string* AISVesselData::mutable_vessel_cert_period_date() {
  set_has_vessel_cert_period_date();
  if (vessel_cert_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_period_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.vessel_cert_period_date)
  return vessel_cert_period_date_;
}
inline ::std::string* AISVesselData::release_vessel_cert_period_date() {
  clear_has_vessel_cert_period_date();
  if (vessel_cert_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vessel_cert_period_date_;
    vessel_cert_period_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_vessel_cert_period_date(::std::string* vessel_cert_period_date) {
  if (vessel_cert_period_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vessel_cert_period_date_;
  }
  if (vessel_cert_period_date) {
    set_has_vessel_cert_period_date();
    vessel_cert_period_date_ = vessel_cert_period_date;
  } else {
    clear_has_vessel_cert_period_date();
    vessel_cert_period_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.vessel_cert_period_date)
}

// optional string vessel_cert_number = 52;
inline bool AISVesselData::has_vessel_cert_number() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void AISVesselData::set_has_vessel_cert_number() {
  _has_bits_[1] |= 0x00080000u;
}
inline void AISVesselData::clear_has_vessel_cert_number() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void AISVesselData::clear_vessel_cert_number() {
  if (vessel_cert_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_number_->clear();
  }
  clear_has_vessel_cert_number();
}
inline const ::std::string& AISVesselData::vessel_cert_number() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.vessel_cert_number)
  return *vessel_cert_number_;
}
inline void AISVesselData::set_vessel_cert_number(const ::std::string& value) {
  set_has_vessel_cert_number();
  if (vessel_cert_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_number_ = new ::std::string;
  }
  vessel_cert_number_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.vessel_cert_number)
}
inline void AISVesselData::set_vessel_cert_number(const char* value) {
  set_has_vessel_cert_number();
  if (vessel_cert_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_number_ = new ::std::string;
  }
  vessel_cert_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.vessel_cert_number)
}
inline void AISVesselData::set_vessel_cert_number(const char* value, size_t size) {
  set_has_vessel_cert_number();
  if (vessel_cert_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_number_ = new ::std::string;
  }
  vessel_cert_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.vessel_cert_number)
}
inline ::std::string* AISVesselData::mutable_vessel_cert_number() {
  set_has_vessel_cert_number();
  if (vessel_cert_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vessel_cert_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.vessel_cert_number)
  return vessel_cert_number_;
}
inline ::std::string* AISVesselData::release_vessel_cert_number() {
  clear_has_vessel_cert_number();
  if (vessel_cert_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vessel_cert_number_;
    vessel_cert_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_vessel_cert_number(::std::string* vessel_cert_number) {
  if (vessel_cert_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vessel_cert_number_;
  }
  if (vessel_cert_number) {
    set_has_vessel_cert_number();
    vessel_cert_number_ = vessel_cert_number;
  } else {
    clear_has_vessel_cert_number();
    vessel_cert_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.vessel_cert_number)
}

// optional string register_period_date = 53;
inline bool AISVesselData::has_register_period_date() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void AISVesselData::set_has_register_period_date() {
  _has_bits_[1] |= 0x00100000u;
}
inline void AISVesselData::clear_has_register_period_date() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void AISVesselData::clear_register_period_date() {
  if (register_period_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_period_date_->clear();
  }
  clear_has_register_period_date();
}
inline const ::std::string& AISVesselData::register_period_date() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.register_period_date)
  return *register_period_date_;
}
inline void AISVesselData::set_register_period_date(const ::std::string& value) {
  set_has_register_period_date();
  if (register_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_period_date_ = new ::std::string;
  }
  register_period_date_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.register_period_date)
}
inline void AISVesselData::set_register_period_date(const char* value) {
  set_has_register_period_date();
  if (register_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_period_date_ = new ::std::string;
  }
  register_period_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.register_period_date)
}
inline void AISVesselData::set_register_period_date(const char* value, size_t size) {
  set_has_register_period_date();
  if (register_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_period_date_ = new ::std::string;
  }
  register_period_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.register_period_date)
}
inline ::std::string* AISVesselData::mutable_register_period_date() {
  set_has_register_period_date();
  if (register_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_period_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.register_period_date)
  return register_period_date_;
}
inline ::std::string* AISVesselData::release_register_period_date() {
  clear_has_register_period_date();
  if (register_period_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_period_date_;
    register_period_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_register_period_date(::std::string* register_period_date) {
  if (register_period_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_period_date_;
  }
  if (register_period_date) {
    set_has_register_period_date();
    register_period_date_ = register_period_date;
  } else {
    clear_has_register_period_date();
    register_period_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.register_period_date)
}

// optional string register_number = 54;
inline bool AISVesselData::has_register_number() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void AISVesselData::set_has_register_number() {
  _has_bits_[1] |= 0x00200000u;
}
inline void AISVesselData::clear_has_register_number() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void AISVesselData::clear_register_number() {
  if (register_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_number_->clear();
  }
  clear_has_register_number();
}
inline const ::std::string& AISVesselData::register_number() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.register_number)
  return *register_number_;
}
inline void AISVesselData::set_register_number(const ::std::string& value) {
  set_has_register_number();
  if (register_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_number_ = new ::std::string;
  }
  register_number_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.register_number)
}
inline void AISVesselData::set_register_number(const char* value) {
  set_has_register_number();
  if (register_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_number_ = new ::std::string;
  }
  register_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.register_number)
}
inline void AISVesselData::set_register_number(const char* value, size_t size) {
  set_has_register_number();
  if (register_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_number_ = new ::std::string;
  }
  register_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.register_number)
}
inline ::std::string* AISVesselData::mutable_register_number() {
  set_has_register_number();
  if (register_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.register_number)
  return register_number_;
}
inline ::std::string* AISVesselData::release_register_number() {
  clear_has_register_number();
  if (register_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_number_;
    register_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_register_number(::std::string* register_number) {
  if (register_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_number_;
  }
  if (register_number) {
    set_has_register_number();
    register_number_ = register_number;
  } else {
    clear_has_register_number();
    register_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.register_number)
}

// optional string group_name = 55;
inline bool AISVesselData::has_group_name() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void AISVesselData::set_has_group_name() {
  _has_bits_[1] |= 0x00400000u;
}
inline void AISVesselData::clear_has_group_name() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void AISVesselData::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& AISVesselData::group_name() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.group_name)
  return *group_name_;
}
inline void AISVesselData::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.group_name)
}
inline void AISVesselData::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.group_name)
}
inline void AISVesselData::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.group_name)
}
inline ::std::string* AISVesselData::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.group_name)
  return group_name_;
}
inline ::std::string* AISVesselData::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.group_name)
}

// optional int32 pos_type = 56;
inline bool AISVesselData::has_pos_type() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void AISVesselData::set_has_pos_type() {
  _has_bits_[1] |= 0x00800000u;
}
inline void AISVesselData::clear_has_pos_type() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void AISVesselData::clear_pos_type() {
  pos_type_ = 0;
  clear_has_pos_type();
}
inline ::google::protobuf::int32 AISVesselData::pos_type() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.pos_type)
  return pos_type_;
}
inline void AISVesselData::set_pos_type(::google::protobuf::int32 value) {
  set_has_pos_type();
  pos_type_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.pos_type)
}

// optional string vdesc = 57;
inline bool AISVesselData::has_vdesc() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void AISVesselData::set_has_vdesc() {
  _has_bits_[1] |= 0x01000000u;
}
inline void AISVesselData::clear_has_vdesc() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void AISVesselData::clear_vdesc() {
  if (vdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vdesc_->clear();
  }
  clear_has_vdesc();
}
inline const ::std::string& AISVesselData::vdesc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.vdesc)
  return *vdesc_;
}
inline void AISVesselData::set_vdesc(const ::std::string& value) {
  set_has_vdesc();
  if (vdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vdesc_ = new ::std::string;
  }
  vdesc_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.vdesc)
}
inline void AISVesselData::set_vdesc(const char* value) {
  set_has_vdesc();
  if (vdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vdesc_ = new ::std::string;
  }
  vdesc_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.vdesc)
}
inline void AISVesselData::set_vdesc(const char* value, size_t size) {
  set_has_vdesc();
  if (vdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vdesc_ = new ::std::string;
  }
  vdesc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.vdesc)
}
inline ::std::string* AISVesselData::mutable_vdesc() {
  set_has_vdesc();
  if (vdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vdesc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.vdesc)
  return vdesc_;
}
inline ::std::string* AISVesselData::release_vdesc() {
  clear_has_vdesc();
  if (vdesc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vdesc_;
    vdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_vdesc(::std::string* vdesc) {
  if (vdesc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vdesc_;
  }
  if (vdesc) {
    set_has_vdesc();
    vdesc_ = vdesc;
  } else {
    clear_has_vdesc();
    vdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.vdesc)
}

// optional int32 type = 58;
inline bool AISVesselData::has_type() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void AISVesselData::set_has_type() {
  _has_bits_[1] |= 0x02000000u;
}
inline void AISVesselData::clear_has_type() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void AISVesselData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AISVesselData::type() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.type)
  return type_;
}
inline void AISVesselData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.type)
}

// optional .com.zhichenhaixin.proto.AISDeviceDataList device_list = 59;
inline bool AISVesselData::has_device_list() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void AISVesselData::set_has_device_list() {
  _has_bits_[1] |= 0x04000000u;
}
inline void AISVesselData::clear_has_device_list() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void AISVesselData::clear_device_list() {
  if (device_list_ != NULL) device_list_->::com::zhichenhaixin::proto::AISDeviceDataList::Clear();
  clear_has_device_list();
}
inline const ::com::zhichenhaixin::proto::AISDeviceDataList& AISVesselData::device_list() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.device_list)
  return device_list_ != NULL ? *device_list_ : *default_instance_->device_list_;
}
inline ::com::zhichenhaixin::proto::AISDeviceDataList* AISVesselData::mutable_device_list() {
  set_has_device_list();
  if (device_list_ == NULL) device_list_ = new ::com::zhichenhaixin::proto::AISDeviceDataList;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.device_list)
  return device_list_;
}
inline ::com::zhichenhaixin::proto::AISDeviceDataList* AISVesselData::release_device_list() {
  clear_has_device_list();
  ::com::zhichenhaixin::proto::AISDeviceDataList* temp = device_list_;
  device_list_ = NULL;
  return temp;
}
inline void AISVesselData::set_allocated_device_list(::com::zhichenhaixin::proto::AISDeviceDataList* device_list) {
  delete device_list_;
  device_list_ = device_list;
  if (device_list) {
    set_has_device_list();
  } else {
    clear_has_device_list();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.device_list)
}

// repeated .com.zhichenhaixin.proto.AISMeet pointMeet = 60;
inline int AISVesselData::pointmeet_size() const {
  return pointmeet_.size();
}
inline void AISVesselData::clear_pointmeet() {
  pointmeet_.Clear();
}
inline const ::com::zhichenhaixin::proto::AISMeet& AISVesselData::pointmeet(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.pointMeet)
  return pointmeet_.Get(index);
}
inline ::com::zhichenhaixin::proto::AISMeet* AISVesselData::mutable_pointmeet(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.pointMeet)
  return pointmeet_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AISMeet* AISVesselData::add_pointmeet() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISVesselData.pointMeet)
  return pointmeet_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISMeet >&
AISVesselData::pointmeet() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISVesselData.pointMeet)
  return pointmeet_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISMeet >*
AISVesselData::mutable_pointmeet() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISVesselData.pointMeet)
  return &pointmeet_;
}

// optional int32 onlineStatus = 61;
inline bool AISVesselData::has_onlinestatus() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void AISVesselData::set_has_onlinestatus() {
  _has_bits_[1] |= 0x10000000u;
}
inline void AISVesselData::clear_has_onlinestatus() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void AISVesselData::clear_onlinestatus() {
  onlinestatus_ = 0;
  clear_has_onlinestatus();
}
inline ::google::protobuf::int32 AISVesselData::onlinestatus() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.onlineStatus)
  return onlinestatus_;
}
inline void AISVesselData::set_onlinestatus(::google::protobuf::int32 value) {
  set_has_onlinestatus();
  onlinestatus_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.onlineStatus)
}

// optional int32 prepCount = 62;
inline bool AISVesselData::has_prepcount() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void AISVesselData::set_has_prepcount() {
  _has_bits_[1] |= 0x20000000u;
}
inline void AISVesselData::clear_has_prepcount() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void AISVesselData::clear_prepcount() {
  prepcount_ = 0;
  clear_has_prepcount();
}
inline ::google::protobuf::int32 AISVesselData::prepcount() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.prepCount)
  return prepcount_;
}
inline void AISVesselData::set_prepcount(::google::protobuf::int32 value) {
  set_has_prepcount();
  prepcount_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.prepCount)
}

// optional int64 utc_spacing = 63;
inline bool AISVesselData::has_utc_spacing() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void AISVesselData::set_has_utc_spacing() {
  _has_bits_[1] |= 0x40000000u;
}
inline void AISVesselData::clear_has_utc_spacing() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void AISVesselData::clear_utc_spacing() {
  utc_spacing_ = GOOGLE_LONGLONG(0);
  clear_has_utc_spacing();
}
inline ::google::protobuf::int64 AISVesselData::utc_spacing() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.utc_spacing)
  return utc_spacing_;
}
inline void AISVesselData::set_utc_spacing(::google::protobuf::int64 value) {
  set_has_utc_spacing();
  utc_spacing_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.utc_spacing)
}

// optional int32 defenceId = 64;
inline bool AISVesselData::has_defenceid() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void AISVesselData::set_has_defenceid() {
  _has_bits_[1] |= 0x80000000u;
}
inline void AISVesselData::clear_has_defenceid() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void AISVesselData::clear_defenceid() {
  defenceid_ = 0;
  clear_has_defenceid();
}
inline ::google::protobuf::int32 AISVesselData::defenceid() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.defenceId)
  return defenceid_;
}
inline void AISVesselData::set_defenceid(::google::protobuf::int32 value) {
  set_has_defenceid();
  defenceid_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.defenceId)
}

// optional string defenceName = 65;
inline bool AISVesselData::has_defencename() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void AISVesselData::set_has_defencename() {
  _has_bits_[2] |= 0x00000001u;
}
inline void AISVesselData::clear_has_defencename() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void AISVesselData::clear_defencename() {
  if (defencename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defencename_->clear();
  }
  clear_has_defencename();
}
inline const ::std::string& AISVesselData::defencename() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.defenceName)
  return *defencename_;
}
inline void AISVesselData::set_defencename(const ::std::string& value) {
  set_has_defencename();
  if (defencename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defencename_ = new ::std::string;
  }
  defencename_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.defenceName)
}
inline void AISVesselData::set_defencename(const char* value) {
  set_has_defencename();
  if (defencename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defencename_ = new ::std::string;
  }
  defencename_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.defenceName)
}
inline void AISVesselData::set_defencename(const char* value, size_t size) {
  set_has_defencename();
  if (defencename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defencename_ = new ::std::string;
  }
  defencename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.defenceName)
}
inline ::std::string* AISVesselData::mutable_defencename() {
  set_has_defencename();
  if (defencename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    defencename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.defenceName)
  return defencename_;
}
inline ::std::string* AISVesselData::release_defencename() {
  clear_has_defencename();
  if (defencename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = defencename_;
    defencename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_defencename(::std::string* defencename) {
  if (defencename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete defencename_;
  }
  if (defencename) {
    set_has_defencename();
    defencename_ = defencename;
  } else {
    clear_has_defencename();
    defencename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.defenceName)
}

// optional int32 defenceType = 66;
inline bool AISVesselData::has_defencetype() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void AISVesselData::set_has_defencetype() {
  _has_bits_[2] |= 0x00000002u;
}
inline void AISVesselData::clear_has_defencetype() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void AISVesselData::clear_defencetype() {
  defencetype_ = 0;
  clear_has_defencetype();
}
inline ::google::protobuf::int32 AISVesselData::defencetype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.defenceType)
  return defencetype_;
}
inline void AISVesselData::set_defencetype(::google::protobuf::int32 value) {
  set_has_defencetype();
  defencetype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.defenceType)
}

// optional double last_lon = 67;
inline bool AISVesselData::has_last_lon() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void AISVesselData::set_has_last_lon() {
  _has_bits_[2] |= 0x00000004u;
}
inline void AISVesselData::clear_has_last_lon() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void AISVesselData::clear_last_lon() {
  last_lon_ = 0;
  clear_has_last_lon();
}
inline double AISVesselData::last_lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.last_lon)
  return last_lon_;
}
inline void AISVesselData::set_last_lon(double value) {
  set_has_last_lon();
  last_lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.last_lon)
}

// optional double last_lat = 68;
inline bool AISVesselData::has_last_lat() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void AISVesselData::set_has_last_lat() {
  _has_bits_[2] |= 0x00000008u;
}
inline void AISVesselData::clear_has_last_lat() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void AISVesselData::clear_last_lat() {
  last_lat_ = 0;
  clear_has_last_lat();
}
inline double AISVesselData::last_lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.last_lat)
  return last_lat_;
}
inline void AISVesselData::set_last_lat(double value) {
  set_has_last_lat();
  last_lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.last_lat)
}

// optional double last_cog = 69;
inline bool AISVesselData::has_last_cog() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void AISVesselData::set_has_last_cog() {
  _has_bits_[2] |= 0x00000010u;
}
inline void AISVesselData::clear_has_last_cog() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void AISVesselData::clear_last_cog() {
  last_cog_ = 0;
  clear_has_last_cog();
}
inline double AISVesselData::last_cog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.last_cog)
  return last_cog_;
}
inline void AISVesselData::set_last_cog(double value) {
  set_has_last_cog();
  last_cog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.last_cog)
}

// optional int32 keyPointNumber = 70;
inline bool AISVesselData::has_keypointnumber() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void AISVesselData::set_has_keypointnumber() {
  _has_bits_[2] |= 0x00000020u;
}
inline void AISVesselData::clear_has_keypointnumber() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void AISVesselData::clear_keypointnumber() {
  keypointnumber_ = 0;
  clear_has_keypointnumber();
}
inline ::google::protobuf::int32 AISVesselData::keypointnumber() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.keyPointNumber)
  return keypointnumber_;
}
inline void AISVesselData::set_keypointnumber(::google::protobuf::int32 value) {
  set_has_keypointnumber();
  keypointnumber_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.keyPointNumber)
}

// optional int32 mark_type = 71;
inline bool AISVesselData::has_mark_type() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void AISVesselData::set_has_mark_type() {
  _has_bits_[2] |= 0x00000040u;
}
inline void AISVesselData::clear_has_mark_type() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void AISVesselData::clear_mark_type() {
  mark_type_ = 0;
  clear_has_mark_type();
}
inline ::google::protobuf::int32 AISVesselData::mark_type() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.mark_type)
  return mark_type_;
}
inline void AISVesselData::set_mark_type(::google::protobuf::int32 value) {
  set_has_mark_type();
  mark_type_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.mark_type)
}

// optional int32 alarmtype = 72;
inline bool AISVesselData::has_alarmtype() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void AISVesselData::set_has_alarmtype() {
  _has_bits_[2] |= 0x00000080u;
}
inline void AISVesselData::clear_has_alarmtype() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void AISVesselData::clear_alarmtype() {
  alarmtype_ = 0;
  clear_has_alarmtype();
}
inline ::google::protobuf::int32 AISVesselData::alarmtype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.alarmtype)
  return alarmtype_;
}
inline void AISVesselData::set_alarmtype(::google::protobuf::int32 value) {
  set_has_alarmtype();
  alarmtype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.alarmtype)
}

// optional int32 alarmgrade = 73;
inline bool AISVesselData::has_alarmgrade() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void AISVesselData::set_has_alarmgrade() {
  _has_bits_[2] |= 0x00000100u;
}
inline void AISVesselData::clear_has_alarmgrade() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void AISVesselData::clear_alarmgrade() {
  alarmgrade_ = 0;
  clear_has_alarmgrade();
}
inline ::google::protobuf::int32 AISVesselData::alarmgrade() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.alarmgrade)
  return alarmgrade_;
}
inline void AISVesselData::set_alarmgrade(::google::protobuf::int32 value) {
  set_has_alarmgrade();
  alarmgrade_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.alarmgrade)
}

// optional double alarmvalue = 74;
inline bool AISVesselData::has_alarmvalue() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void AISVesselData::set_has_alarmvalue() {
  _has_bits_[2] |= 0x00000200u;
}
inline void AISVesselData::clear_has_alarmvalue() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void AISVesselData::clear_alarmvalue() {
  alarmvalue_ = 0;
  clear_has_alarmvalue();
}
inline double AISVesselData::alarmvalue() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.alarmvalue)
  return alarmvalue_;
}
inline void AISVesselData::set_alarmvalue(double value) {
  set_has_alarmvalue();
  alarmvalue_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.alarmvalue)
}

// optional double riskvalue = 75;
inline bool AISVesselData::has_riskvalue() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void AISVesselData::set_has_riskvalue() {
  _has_bits_[2] |= 0x00000400u;
}
inline void AISVesselData::clear_has_riskvalue() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void AISVesselData::clear_riskvalue() {
  riskvalue_ = 0;
  clear_has_riskvalue();
}
inline double AISVesselData::riskvalue() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.riskvalue)
  return riskvalue_;
}
inline void AISVesselData::set_riskvalue(double value) {
  set_has_riskvalue();
  riskvalue_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.riskvalue)
}

// optional string cpaAttr = 76;
inline bool AISVesselData::has_cpaattr() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void AISVesselData::set_has_cpaattr() {
  _has_bits_[2] |= 0x00000800u;
}
inline void AISVesselData::clear_has_cpaattr() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void AISVesselData::clear_cpaattr() {
  if (cpaattr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpaattr_->clear();
  }
  clear_has_cpaattr();
}
inline const ::std::string& AISVesselData::cpaattr() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.cpaAttr)
  return *cpaattr_;
}
inline void AISVesselData::set_cpaattr(const ::std::string& value) {
  set_has_cpaattr();
  if (cpaattr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpaattr_ = new ::std::string;
  }
  cpaattr_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.cpaAttr)
}
inline void AISVesselData::set_cpaattr(const char* value) {
  set_has_cpaattr();
  if (cpaattr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpaattr_ = new ::std::string;
  }
  cpaattr_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISVesselData.cpaAttr)
}
inline void AISVesselData::set_cpaattr(const char* value, size_t size) {
  set_has_cpaattr();
  if (cpaattr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpaattr_ = new ::std::string;
  }
  cpaattr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISVesselData.cpaAttr)
}
inline ::std::string* AISVesselData::mutable_cpaattr() {
  set_has_cpaattr();
  if (cpaattr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpaattr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselData.cpaAttr)
  return cpaattr_;
}
inline ::std::string* AISVesselData::release_cpaattr() {
  clear_has_cpaattr();
  if (cpaattr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cpaattr_;
    cpaattr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISVesselData::set_allocated_cpaattr(::std::string* cpaattr) {
  if (cpaattr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cpaattr_;
  }
  if (cpaattr) {
    set_has_cpaattr();
    cpaattr_ = cpaattr;
  } else {
    clear_has_cpaattr();
    cpaattr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISVesselData.cpaAttr)
}

// optional bool ricIsSound = 77;
inline bool AISVesselData::has_ricissound() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void AISVesselData::set_has_ricissound() {
  _has_bits_[2] |= 0x00001000u;
}
inline void AISVesselData::clear_has_ricissound() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void AISVesselData::clear_ricissound() {
  ricissound_ = false;
  clear_has_ricissound();
}
inline bool AISVesselData::ricissound() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ricIsSound)
  return ricissound_;
}
inline void AISVesselData::set_ricissound(bool value) {
  set_has_ricissound();
  ricissound_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ricIsSound)
}

// optional bool ricIsPopup = 78;
inline bool AISVesselData::has_ricispopup() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void AISVesselData::set_has_ricispopup() {
  _has_bits_[2] |= 0x00002000u;
}
inline void AISVesselData::clear_has_ricispopup() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void AISVesselData::clear_ricispopup() {
  ricispopup_ = false;
  clear_has_ricispopup();
}
inline bool AISVesselData::ricispopup() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselData.ricIsPopup)
  return ricispopup_;
}
inline void AISVesselData::set_ricispopup(bool value) {
  set_has_ricispopup();
  ricispopup_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselData.ricIsPopup)
}

// -------------------------------------------------------------------

// AISVesselDataList

// repeated .com.zhichenhaixin.proto.AISVesselData aisData = 1;
inline int AISVesselDataList::aisdata_size() const {
  return aisdata_.size();
}
inline void AISVesselDataList::clear_aisdata() {
  aisdata_.Clear();
}
inline const ::com::zhichenhaixin::proto::AISVesselData& AISVesselDataList::aisdata(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselDataList.aisData)
  return aisdata_.Get(index);
}
inline ::com::zhichenhaixin::proto::AISVesselData* AISVesselDataList::mutable_aisdata(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISVesselDataList.aisData)
  return aisdata_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AISVesselData* AISVesselDataList::add_aisdata() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISVesselDataList.aisData)
  return aisdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISVesselData >&
AISVesselDataList::aisdata() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISVesselDataList.aisData)
  return aisdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISVesselData >*
AISVesselDataList::mutable_aisdata() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISVesselDataList.aisData)
  return &aisdata_;
}

// optional int32 length = 2;
inline bool AISVesselDataList::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AISVesselDataList::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AISVesselDataList::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AISVesselDataList::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 AISVesselDataList::length() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISVesselDataList.length)
  return length_;
}
inline void AISVesselDataList::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISVesselDataList.length)
}

// -------------------------------------------------------------------

// VesselTrack

// required string id = 1;
inline bool VesselTrack::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VesselTrack::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VesselTrack::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VesselTrack::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& VesselTrack::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.id)
  return *id_;
}
inline void VesselTrack::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.id)
}
inline void VesselTrack::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselTrack.id)
}
inline void VesselTrack::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselTrack.id)
}
inline ::std::string* VesselTrack::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselTrack.id)
  return id_;
}
inline ::std::string* VesselTrack::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselTrack::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselTrack.id)
}

// required int32 mmsi = 2;
inline bool VesselTrack::has_mmsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VesselTrack::set_has_mmsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VesselTrack::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VesselTrack::clear_mmsi() {
  mmsi_ = 0;
  clear_has_mmsi();
}
inline ::google::protobuf::int32 VesselTrack::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.mmsi)
  return mmsi_;
}
inline void VesselTrack::set_mmsi(::google::protobuf::int32 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.mmsi)
}

// required string shiptype = 3;
inline bool VesselTrack::has_shiptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VesselTrack::set_has_shiptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VesselTrack::clear_has_shiptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VesselTrack::clear_shiptype() {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_->clear();
  }
  clear_has_shiptype();
}
inline const ::std::string& VesselTrack::shiptype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.shiptype)
  return *shiptype_;
}
inline void VesselTrack::set_shiptype(const ::std::string& value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.shiptype)
}
inline void VesselTrack::set_shiptype(const char* value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.VesselTrack.shiptype)
}
inline void VesselTrack::set_shiptype(const char* value, size_t size) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.VesselTrack.shiptype)
}
inline ::std::string* VesselTrack::mutable_shiptype() {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.VesselTrack.shiptype)
  return shiptype_;
}
inline ::std::string* VesselTrack::release_shiptype() {
  clear_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shiptype_;
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VesselTrack::set_allocated_shiptype(::std::string* shiptype) {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shiptype_;
  }
  if (shiptype) {
    set_has_shiptype();
    shiptype_ = shiptype;
  } else {
    clear_has_shiptype();
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.VesselTrack.shiptype)
}

// required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
inline bool VesselTrack::has_navstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VesselTrack::set_has_navstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VesselTrack::clear_has_navstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VesselTrack::clear_navstatus() {
  navstatus_ = 0;
  clear_has_navstatus();
}
inline ::com::zhichenhaixin::proto::NAVI_STATUS VesselTrack::navstatus() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.navStatus)
  return static_cast< ::com::zhichenhaixin::proto::NAVI_STATUS >(navstatus_);
}
inline void VesselTrack::set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value) {
  assert(::com::zhichenhaixin::proto::NAVI_STATUS_IsValid(value));
  set_has_navstatus();
  navstatus_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.navStatus)
}

// required float rot = 5;
inline bool VesselTrack::has_rot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VesselTrack::set_has_rot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VesselTrack::clear_has_rot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VesselTrack::clear_rot() {
  rot_ = 0;
  clear_has_rot();
}
inline float VesselTrack::rot() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.rot)
  return rot_;
}
inline void VesselTrack::set_rot(float value) {
  set_has_rot();
  rot_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.rot)
}

// required float sog = 6;
inline bool VesselTrack::has_sog() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VesselTrack::set_has_sog() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VesselTrack::clear_has_sog() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VesselTrack::clear_sog() {
  sog_ = 0;
  clear_has_sog();
}
inline float VesselTrack::sog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.sog)
  return sog_;
}
inline void VesselTrack::set_sog(float value) {
  set_has_sog();
  sog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.sog)
}

// required double lon = 7;
inline bool VesselTrack::has_lon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VesselTrack::set_has_lon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VesselTrack::clear_has_lon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VesselTrack::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double VesselTrack::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.lon)
  return lon_;
}
inline void VesselTrack::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.lon)
}

// required double lat = 8;
inline bool VesselTrack::has_lat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VesselTrack::set_has_lat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VesselTrack::clear_has_lat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VesselTrack::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double VesselTrack::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.lat)
  return lat_;
}
inline void VesselTrack::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.lat)
}

// required float cog = 9;
inline bool VesselTrack::has_cog() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VesselTrack::set_has_cog() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VesselTrack::clear_has_cog() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VesselTrack::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
inline float VesselTrack::cog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.cog)
  return cog_;
}
inline void VesselTrack::set_cog(float value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.cog)
}

// required float heading = 10;
inline bool VesselTrack::has_heading() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VesselTrack::set_has_heading() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VesselTrack::clear_has_heading() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VesselTrack::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float VesselTrack::heading() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.heading)
  return heading_;
}
inline void VesselTrack::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.heading)
}

// required uint64 UTC = 11;
inline bool VesselTrack::has_utc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VesselTrack::set_has_utc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VesselTrack::clear_has_utc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VesselTrack::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 VesselTrack::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.VesselTrack.UTC)
  return utc_;
}
inline void VesselTrack::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.VesselTrack.UTC)
}

// -------------------------------------------------------------------

// BaseStationReport

// required int32 id = 1;
inline bool BaseStationReport::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseStationReport::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseStationReport::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseStationReport::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BaseStationReport::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.id)
  return id_;
}
inline void BaseStationReport::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.id)
}

// required int32 repeatIndicator = 2;
inline bool BaseStationReport::has_repeatindicator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseStationReport::set_has_repeatindicator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseStationReport::clear_has_repeatindicator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseStationReport::clear_repeatindicator() {
  repeatindicator_ = 0;
  clear_has_repeatindicator();
}
inline ::google::protobuf::int32 BaseStationReport::repeatindicator() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.repeatIndicator)
  return repeatindicator_;
}
inline void BaseStationReport::set_repeatindicator(::google::protobuf::int32 value) {
  set_has_repeatindicator();
  repeatindicator_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.repeatIndicator)
}

// required int32 mmsi = 3;
inline bool BaseStationReport::has_mmsi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseStationReport::set_has_mmsi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseStationReport::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseStationReport::clear_mmsi() {
  mmsi_ = 0;
  clear_has_mmsi();
}
inline ::google::protobuf::int32 BaseStationReport::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.mmsi)
  return mmsi_;
}
inline void BaseStationReport::set_mmsi(::google::protobuf::int32 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.mmsi)
}

// required int32 year = 4;
inline bool BaseStationReport::has_year() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseStationReport::set_has_year() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseStationReport::clear_has_year() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseStationReport::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 BaseStationReport::year() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.year)
  return year_;
}
inline void BaseStationReport::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.year)
}

// required int32 month = 5;
inline bool BaseStationReport::has_month() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseStationReport::set_has_month() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseStationReport::clear_has_month() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseStationReport::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 BaseStationReport::month() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.month)
  return month_;
}
inline void BaseStationReport::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.month)
}

// required int32 day = 6;
inline bool BaseStationReport::has_day() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseStationReport::set_has_day() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseStationReport::clear_has_day() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseStationReport::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 BaseStationReport::day() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.day)
  return day_;
}
inline void BaseStationReport::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.day)
}

// required int32 hour = 7;
inline bool BaseStationReport::has_hour() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseStationReport::set_has_hour() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseStationReport::clear_has_hour() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseStationReport::clear_hour() {
  hour_ = 0;
  clear_has_hour();
}
inline ::google::protobuf::int32 BaseStationReport::hour() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.hour)
  return hour_;
}
inline void BaseStationReport::set_hour(::google::protobuf::int32 value) {
  set_has_hour();
  hour_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.hour)
}

// required int32 minute = 8;
inline bool BaseStationReport::has_minute() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BaseStationReport::set_has_minute() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BaseStationReport::clear_has_minute() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BaseStationReport::clear_minute() {
  minute_ = 0;
  clear_has_minute();
}
inline ::google::protobuf::int32 BaseStationReport::minute() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.minute)
  return minute_;
}
inline void BaseStationReport::set_minute(::google::protobuf::int32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.minute)
}

// required int32 second = 9;
inline bool BaseStationReport::has_second() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BaseStationReport::set_has_second() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BaseStationReport::clear_has_second() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BaseStationReport::clear_second() {
  second_ = 0;
  clear_has_second();
}
inline ::google::protobuf::int32 BaseStationReport::second() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.second)
  return second_;
}
inline void BaseStationReport::set_second(::google::protobuf::int32 value) {
  set_has_second();
  second_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.second)
}

// required int32 positionAccuracy = 10;
inline bool BaseStationReport::has_positionaccuracy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BaseStationReport::set_has_positionaccuracy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BaseStationReport::clear_has_positionaccuracy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BaseStationReport::clear_positionaccuracy() {
  positionaccuracy_ = 0;
  clear_has_positionaccuracy();
}
inline ::google::protobuf::int32 BaseStationReport::positionaccuracy() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.positionAccuracy)
  return positionaccuracy_;
}
inline void BaseStationReport::set_positionaccuracy(::google::protobuf::int32 value) {
  set_has_positionaccuracy();
  positionaccuracy_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.positionAccuracy)
}

// required double lon = 11;
inline bool BaseStationReport::has_lon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BaseStationReport::set_has_lon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BaseStationReport::clear_has_lon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BaseStationReport::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double BaseStationReport::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.lon)
  return lon_;
}
inline void BaseStationReport::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.lon)
}

// required double lat = 12;
inline bool BaseStationReport::has_lat() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BaseStationReport::set_has_lat() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BaseStationReport::clear_has_lat() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BaseStationReport::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double BaseStationReport::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.lat)
  return lat_;
}
inline void BaseStationReport::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.lat)
}

// required int32 fixType = 13;
inline bool BaseStationReport::has_fixtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BaseStationReport::set_has_fixtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BaseStationReport::clear_has_fixtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BaseStationReport::clear_fixtype() {
  fixtype_ = 0;
  clear_has_fixtype();
}
inline ::google::protobuf::int32 BaseStationReport::fixtype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.fixType)
  return fixtype_;
}
inline void BaseStationReport::set_fixtype(::google::protobuf::int32 value) {
  set_has_fixtype();
  fixtype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.fixType)
}

// required uint64 UTC = 14;
inline bool BaseStationReport::has_utc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BaseStationReport::set_has_utc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BaseStationReport::clear_has_utc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BaseStationReport::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 BaseStationReport::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.BaseStationReport.UTC)
  return utc_;
}
inline void BaseStationReport::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.BaseStationReport.UTC)
}

// -------------------------------------------------------------------

// AidtoNavigationReport

// required int32 id = 1;
inline bool AidtoNavigationReport::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AidtoNavigationReport::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AidtoNavigationReport::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AidtoNavigationReport::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AidtoNavigationReport::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.id)
  return id_;
}
inline void AidtoNavigationReport::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.id)
}

// required int32 repeatIndicator = 2;
inline bool AidtoNavigationReport::has_repeatindicator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AidtoNavigationReport::set_has_repeatindicator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AidtoNavigationReport::clear_has_repeatindicator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AidtoNavigationReport::clear_repeatindicator() {
  repeatindicator_ = 0;
  clear_has_repeatindicator();
}
inline ::google::protobuf::int32 AidtoNavigationReport::repeatindicator() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.repeatIndicator)
  return repeatindicator_;
}
inline void AidtoNavigationReport::set_repeatindicator(::google::protobuf::int32 value) {
  set_has_repeatindicator();
  repeatindicator_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.repeatIndicator)
}

// required int32 mmsi = 3;
inline bool AidtoNavigationReport::has_mmsi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AidtoNavigationReport::set_has_mmsi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AidtoNavigationReport::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AidtoNavigationReport::clear_mmsi() {
  mmsi_ = 0;
  clear_has_mmsi();
}
inline ::google::protobuf::int32 AidtoNavigationReport::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.mmsi)
  return mmsi_;
}
inline void AidtoNavigationReport::set_mmsi(::google::protobuf::int32 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.mmsi)
}

// required .com.zhichenhaixin.proto.ATON_TYPE atonType = 4;
inline bool AidtoNavigationReport::has_atontype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AidtoNavigationReport::set_has_atontype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AidtoNavigationReport::clear_has_atontype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AidtoNavigationReport::clear_atontype() {
  atontype_ = 0;
  clear_has_atontype();
}
inline ::com::zhichenhaixin::proto::ATON_TYPE AidtoNavigationReport::atontype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.atonType)
  return static_cast< ::com::zhichenhaixin::proto::ATON_TYPE >(atontype_);
}
inline void AidtoNavigationReport::set_atontype(::com::zhichenhaixin::proto::ATON_TYPE value) {
  assert(::com::zhichenhaixin::proto::ATON_TYPE_IsValid(value));
  set_has_atontype();
  atontype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.atonType)
}

// required string name = 5;
inline bool AidtoNavigationReport::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AidtoNavigationReport::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AidtoNavigationReport::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AidtoNavigationReport::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AidtoNavigationReport::name() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.name)
  return *name_;
}
inline void AidtoNavigationReport::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.name)
}
inline void AidtoNavigationReport::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AidtoNavigationReport.name)
}
inline void AidtoNavigationReport::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AidtoNavigationReport.name)
}
inline ::std::string* AidtoNavigationReport::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AidtoNavigationReport.name)
  return name_;
}
inline ::std::string* AidtoNavigationReport::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AidtoNavigationReport::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AidtoNavigationReport.name)
}

// required int32 positionAccuracy = 6;
inline bool AidtoNavigationReport::has_positionaccuracy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AidtoNavigationReport::set_has_positionaccuracy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AidtoNavigationReport::clear_has_positionaccuracy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AidtoNavigationReport::clear_positionaccuracy() {
  positionaccuracy_ = 0;
  clear_has_positionaccuracy();
}
inline ::google::protobuf::int32 AidtoNavigationReport::positionaccuracy() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.positionAccuracy)
  return positionaccuracy_;
}
inline void AidtoNavigationReport::set_positionaccuracy(::google::protobuf::int32 value) {
  set_has_positionaccuracy();
  positionaccuracy_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.positionAccuracy)
}

// required double lon = 7;
inline bool AidtoNavigationReport::has_lon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AidtoNavigationReport::set_has_lon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AidtoNavigationReport::clear_has_lon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AidtoNavigationReport::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double AidtoNavigationReport::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.lon)
  return lon_;
}
inline void AidtoNavigationReport::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.lon)
}

// required double lat = 8;
inline bool AidtoNavigationReport::has_lat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AidtoNavigationReport::set_has_lat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AidtoNavigationReport::clear_has_lat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AidtoNavigationReport::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double AidtoNavigationReport::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.lat)
  return lat_;
}
inline void AidtoNavigationReport::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.lat)
}

// required int32 toBow = 9;
inline bool AidtoNavigationReport::has_tobow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AidtoNavigationReport::set_has_tobow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AidtoNavigationReport::clear_has_tobow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AidtoNavigationReport::clear_tobow() {
  tobow_ = 0;
  clear_has_tobow();
}
inline ::google::protobuf::int32 AidtoNavigationReport::tobow() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.toBow)
  return tobow_;
}
inline void AidtoNavigationReport::set_tobow(::google::protobuf::int32 value) {
  set_has_tobow();
  tobow_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.toBow)
}

// required int32 toStern = 10;
inline bool AidtoNavigationReport::has_tostern() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AidtoNavigationReport::set_has_tostern() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AidtoNavigationReport::clear_has_tostern() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AidtoNavigationReport::clear_tostern() {
  tostern_ = 0;
  clear_has_tostern();
}
inline ::google::protobuf::int32 AidtoNavigationReport::tostern() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.toStern)
  return tostern_;
}
inline void AidtoNavigationReport::set_tostern(::google::protobuf::int32 value) {
  set_has_tostern();
  tostern_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.toStern)
}

// required int32 toPort = 11;
inline bool AidtoNavigationReport::has_toport() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AidtoNavigationReport::set_has_toport() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AidtoNavigationReport::clear_has_toport() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AidtoNavigationReport::clear_toport() {
  toport_ = 0;
  clear_has_toport();
}
inline ::google::protobuf::int32 AidtoNavigationReport::toport() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.toPort)
  return toport_;
}
inline void AidtoNavigationReport::set_toport(::google::protobuf::int32 value) {
  set_has_toport();
  toport_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.toPort)
}

// required int32 toStarboard = 12;
inline bool AidtoNavigationReport::has_tostarboard() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AidtoNavigationReport::set_has_tostarboard() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AidtoNavigationReport::clear_has_tostarboard() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AidtoNavigationReport::clear_tostarboard() {
  tostarboard_ = 0;
  clear_has_tostarboard();
}
inline ::google::protobuf::int32 AidtoNavigationReport::tostarboard() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.toStarboard)
  return tostarboard_;
}
inline void AidtoNavigationReport::set_tostarboard(::google::protobuf::int32 value) {
  set_has_tostarboard();
  tostarboard_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.toStarboard)
}

// required int32 fixType = 13;
inline bool AidtoNavigationReport::has_fixtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AidtoNavigationReport::set_has_fixtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AidtoNavigationReport::clear_has_fixtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AidtoNavigationReport::clear_fixtype() {
  fixtype_ = 0;
  clear_has_fixtype();
}
inline ::google::protobuf::int32 AidtoNavigationReport::fixtype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.fixType)
  return fixtype_;
}
inline void AidtoNavigationReport::set_fixtype(::google::protobuf::int32 value) {
  set_has_fixtype();
  fixtype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.fixType)
}

// required uint64 UTC = 14;
inline bool AidtoNavigationReport::has_utc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AidtoNavigationReport::set_has_utc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AidtoNavigationReport::clear_has_utc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AidtoNavigationReport::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 AidtoNavigationReport::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AidtoNavigationReport.UTC)
  return utc_;
}
inline void AidtoNavigationReport::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AidtoNavigationReport.UTC)
}

// -------------------------------------------------------------------

// AIS

// required int32 flag = 1;
inline bool AIS::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIS::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIS::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIS::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 AIS::flag() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.flag)
  return flag_;
}
inline void AIS::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AIS.flag)
}

// required string sourceId = 2;
inline bool AIS::has_sourceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIS::set_has_sourceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIS::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIS::clear_sourceid() {
  if (sourceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_->clear();
  }
  clear_has_sourceid();
}
inline const ::std::string& AIS::sourceid() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.sourceId)
  return *sourceid_;
}
inline void AIS::set_sourceid(const ::std::string& value) {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  sourceid_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AIS.sourceId)
}
inline void AIS::set_sourceid(const char* value) {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  sourceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AIS.sourceId)
}
inline void AIS::set_sourceid(const char* value, size_t size) {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  sourceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AIS.sourceId)
}
inline ::std::string* AIS::mutable_sourceid() {
  set_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.sourceId)
  return sourceid_;
}
inline ::std::string* AIS::release_sourceid() {
  clear_has_sourceid();
  if (sourceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sourceid_;
    sourceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AIS::set_allocated_sourceid(::std::string* sourceid) {
  if (sourceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sourceid_;
  }
  if (sourceid) {
    set_has_sourceid();
    sourceid_ = sourceid;
  } else {
    clear_has_sourceid();
    sourceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.sourceId)
}

// optional .com.zhichenhaixin.proto.VesselInfo vesselInfo = 3;
inline bool AIS::has_vesselinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIS::set_has_vesselinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIS::clear_has_vesselinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIS::clear_vesselinfo() {
  if (vesselinfo_ != NULL) vesselinfo_->::com::zhichenhaixin::proto::VesselInfo::Clear();
  clear_has_vesselinfo();
}
inline const ::com::zhichenhaixin::proto::VesselInfo& AIS::vesselinfo() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.vesselInfo)
  return vesselinfo_ != NULL ? *vesselinfo_ : *default_instance_->vesselinfo_;
}
inline ::com::zhichenhaixin::proto::VesselInfo* AIS::mutable_vesselinfo() {
  set_has_vesselinfo();
  if (vesselinfo_ == NULL) vesselinfo_ = new ::com::zhichenhaixin::proto::VesselInfo;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.vesselInfo)
  return vesselinfo_;
}
inline ::com::zhichenhaixin::proto::VesselInfo* AIS::release_vesselinfo() {
  clear_has_vesselinfo();
  ::com::zhichenhaixin::proto::VesselInfo* temp = vesselinfo_;
  vesselinfo_ = NULL;
  return temp;
}
inline void AIS::set_allocated_vesselinfo(::com::zhichenhaixin::proto::VesselInfo* vesselinfo) {
  delete vesselinfo_;
  vesselinfo_ = vesselinfo;
  if (vesselinfo) {
    set_has_vesselinfo();
  } else {
    clear_has_vesselinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.vesselInfo)
}

// optional .com.zhichenhaixin.proto.VesselTrack vesselTrack = 4;
inline bool AIS::has_vesseltrack() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIS::set_has_vesseltrack() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIS::clear_has_vesseltrack() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIS::clear_vesseltrack() {
  if (vesseltrack_ != NULL) vesseltrack_->::com::zhichenhaixin::proto::VesselTrack::Clear();
  clear_has_vesseltrack();
}
inline const ::com::zhichenhaixin::proto::VesselTrack& AIS::vesseltrack() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.vesselTrack)
  return vesseltrack_ != NULL ? *vesseltrack_ : *default_instance_->vesseltrack_;
}
inline ::com::zhichenhaixin::proto::VesselTrack* AIS::mutable_vesseltrack() {
  set_has_vesseltrack();
  if (vesseltrack_ == NULL) vesseltrack_ = new ::com::zhichenhaixin::proto::VesselTrack;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.vesselTrack)
  return vesseltrack_;
}
inline ::com::zhichenhaixin::proto::VesselTrack* AIS::release_vesseltrack() {
  clear_has_vesseltrack();
  ::com::zhichenhaixin::proto::VesselTrack* temp = vesseltrack_;
  vesseltrack_ = NULL;
  return temp;
}
inline void AIS::set_allocated_vesseltrack(::com::zhichenhaixin::proto::VesselTrack* vesseltrack) {
  delete vesseltrack_;
  vesseltrack_ = vesseltrack;
  if (vesseltrack) {
    set_has_vesseltrack();
  } else {
    clear_has_vesseltrack();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.vesselTrack)
}

// optional .com.zhichenhaixin.proto.BaseStationReport baseStationReport = 5;
inline bool AIS::has_basestationreport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AIS::set_has_basestationreport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AIS::clear_has_basestationreport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AIS::clear_basestationreport() {
  if (basestationreport_ != NULL) basestationreport_->::com::zhichenhaixin::proto::BaseStationReport::Clear();
  clear_has_basestationreport();
}
inline const ::com::zhichenhaixin::proto::BaseStationReport& AIS::basestationreport() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.baseStationReport)
  return basestationreport_ != NULL ? *basestationreport_ : *default_instance_->basestationreport_;
}
inline ::com::zhichenhaixin::proto::BaseStationReport* AIS::mutable_basestationreport() {
  set_has_basestationreport();
  if (basestationreport_ == NULL) basestationreport_ = new ::com::zhichenhaixin::proto::BaseStationReport;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.baseStationReport)
  return basestationreport_;
}
inline ::com::zhichenhaixin::proto::BaseStationReport* AIS::release_basestationreport() {
  clear_has_basestationreport();
  ::com::zhichenhaixin::proto::BaseStationReport* temp = basestationreport_;
  basestationreport_ = NULL;
  return temp;
}
inline void AIS::set_allocated_basestationreport(::com::zhichenhaixin::proto::BaseStationReport* basestationreport) {
  delete basestationreport_;
  basestationreport_ = basestationreport;
  if (basestationreport) {
    set_has_basestationreport();
  } else {
    clear_has_basestationreport();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.baseStationReport)
}

// optional .com.zhichenhaixin.proto.AidtoNavigationReport aidtoNavigationReport = 6;
inline bool AIS::has_aidtonavigationreport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AIS::set_has_aidtonavigationreport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AIS::clear_has_aidtonavigationreport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AIS::clear_aidtonavigationreport() {
  if (aidtonavigationreport_ != NULL) aidtonavigationreport_->::com::zhichenhaixin::proto::AidtoNavigationReport::Clear();
  clear_has_aidtonavigationreport();
}
inline const ::com::zhichenhaixin::proto::AidtoNavigationReport& AIS::aidtonavigationreport() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AIS.aidtoNavigationReport)
  return aidtonavigationreport_ != NULL ? *aidtonavigationreport_ : *default_instance_->aidtonavigationreport_;
}
inline ::com::zhichenhaixin::proto::AidtoNavigationReport* AIS::mutable_aidtonavigationreport() {
  set_has_aidtonavigationreport();
  if (aidtonavigationreport_ == NULL) aidtonavigationreport_ = new ::com::zhichenhaixin::proto::AidtoNavigationReport;
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AIS.aidtoNavigationReport)
  return aidtonavigationreport_;
}
inline ::com::zhichenhaixin::proto::AidtoNavigationReport* AIS::release_aidtonavigationreport() {
  clear_has_aidtonavigationreport();
  ::com::zhichenhaixin::proto::AidtoNavigationReport* temp = aidtonavigationreport_;
  aidtonavigationreport_ = NULL;
  return temp;
}
inline void AIS::set_allocated_aidtonavigationreport(::com::zhichenhaixin::proto::AidtoNavigationReport* aidtonavigationreport) {
  delete aidtonavigationreport_;
  aidtonavigationreport_ = aidtonavigationreport;
  if (aidtonavigationreport) {
    set_has_aidtonavigationreport();
  } else {
    clear_has_aidtonavigationreport();
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AIS.aidtoNavigationReport)
}

// -------------------------------------------------------------------

// AISList

// required uint64 UTC = 1;
inline bool AISList::has_utc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AISList::set_has_utc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AISList::clear_has_utc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AISList::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 AISList::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISList.UTC)
  return utc_;
}
inline void AISList::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISList.UTC)
}

// repeated .com.zhichenhaixin.proto.AIS ais = 2;
inline int AISList::ais_size() const {
  return ais_.size();
}
inline void AISList::clear_ais() {
  ais_.Clear();
}
inline const ::com::zhichenhaixin::proto::AIS& AISList::ais(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISList.ais)
  return ais_.Get(index);
}
inline ::com::zhichenhaixin::proto::AIS* AISList::mutable_ais(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISList.ais)
  return ais_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AIS* AISList::add_ais() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISList.ais)
  return ais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >&
AISList::ais() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISList.ais)
  return ais_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AIS >*
AISList::mutable_ais() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISList.ais)
  return &ais_;
}

// -------------------------------------------------------------------

// AISHistoryTrackPoint

// required string id = 1;
inline bool AISHistoryTrackPoint::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AISHistoryTrackPoint::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AISHistoryTrackPoint::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AISHistoryTrackPoint::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AISHistoryTrackPoint::id() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.id)
  return *id_;
}
inline void AISHistoryTrackPoint::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.id)
}
inline void AISHistoryTrackPoint::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISHistoryTrackPoint.id)
}
inline void AISHistoryTrackPoint::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISHistoryTrackPoint.id)
}
inline ::std::string* AISHistoryTrackPoint::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISHistoryTrackPoint.id)
  return id_;
}
inline ::std::string* AISHistoryTrackPoint::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISHistoryTrackPoint::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISHistoryTrackPoint.id)
}

// required int64 mmsi = 2;
inline bool AISHistoryTrackPoint::has_mmsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AISHistoryTrackPoint::set_has_mmsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AISHistoryTrackPoint::clear_has_mmsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AISHistoryTrackPoint::clear_mmsi() {
  mmsi_ = GOOGLE_LONGLONG(0);
  clear_has_mmsi();
}
inline ::google::protobuf::int64 AISHistoryTrackPoint::mmsi() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.mmsi)
  return mmsi_;
}
inline void AISHistoryTrackPoint::set_mmsi(::google::protobuf::int64 value) {
  set_has_mmsi();
  mmsi_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.mmsi)
}

// required string shiptype = 3;
inline bool AISHistoryTrackPoint::has_shiptype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AISHistoryTrackPoint::set_has_shiptype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AISHistoryTrackPoint::clear_has_shiptype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AISHistoryTrackPoint::clear_shiptype() {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_->clear();
  }
  clear_has_shiptype();
}
inline const ::std::string& AISHistoryTrackPoint::shiptype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.shiptype)
  return *shiptype_;
}
inline void AISHistoryTrackPoint::set_shiptype(const ::std::string& value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.shiptype)
}
inline void AISHistoryTrackPoint::set_shiptype(const char* value) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zhichenhaixin.proto.AISHistoryTrackPoint.shiptype)
}
inline void AISHistoryTrackPoint::set_shiptype(const char* value, size_t size) {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  shiptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zhichenhaixin.proto.AISHistoryTrackPoint.shiptype)
}
inline ::std::string* AISHistoryTrackPoint::mutable_shiptype() {
  set_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shiptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISHistoryTrackPoint.shiptype)
  return shiptype_;
}
inline ::std::string* AISHistoryTrackPoint::release_shiptype() {
  clear_has_shiptype();
  if (shiptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shiptype_;
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AISHistoryTrackPoint::set_allocated_shiptype(::std::string* shiptype) {
  if (shiptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shiptype_;
  }
  if (shiptype) {
    set_has_shiptype();
    shiptype_ = shiptype;
  } else {
    clear_has_shiptype();
    shiptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.zhichenhaixin.proto.AISHistoryTrackPoint.shiptype)
}

// required .com.zhichenhaixin.proto.NAVI_STATUS navStatus = 4;
inline bool AISHistoryTrackPoint::has_navstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AISHistoryTrackPoint::set_has_navstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AISHistoryTrackPoint::clear_has_navstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AISHistoryTrackPoint::clear_navstatus() {
  navstatus_ = 0;
  clear_has_navstatus();
}
inline ::com::zhichenhaixin::proto::NAVI_STATUS AISHistoryTrackPoint::navstatus() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.navStatus)
  return static_cast< ::com::zhichenhaixin::proto::NAVI_STATUS >(navstatus_);
}
inline void AISHistoryTrackPoint::set_navstatus(::com::zhichenhaixin::proto::NAVI_STATUS value) {
  assert(::com::zhichenhaixin::proto::NAVI_STATUS_IsValid(value));
  set_has_navstatus();
  navstatus_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.navStatus)
}

// required float rot = 5;
inline bool AISHistoryTrackPoint::has_rot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AISHistoryTrackPoint::set_has_rot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AISHistoryTrackPoint::clear_has_rot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AISHistoryTrackPoint::clear_rot() {
  rot_ = 0;
  clear_has_rot();
}
inline float AISHistoryTrackPoint::rot() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.rot)
  return rot_;
}
inline void AISHistoryTrackPoint::set_rot(float value) {
  set_has_rot();
  rot_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.rot)
}

// required float sog = 6;
inline bool AISHistoryTrackPoint::has_sog() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AISHistoryTrackPoint::set_has_sog() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AISHistoryTrackPoint::clear_has_sog() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AISHistoryTrackPoint::clear_sog() {
  sog_ = 0;
  clear_has_sog();
}
inline float AISHistoryTrackPoint::sog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.sog)
  return sog_;
}
inline void AISHistoryTrackPoint::set_sog(float value) {
  set_has_sog();
  sog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.sog)
}

// required double lon = 7;
inline bool AISHistoryTrackPoint::has_lon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AISHistoryTrackPoint::set_has_lon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AISHistoryTrackPoint::clear_has_lon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AISHistoryTrackPoint::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline double AISHistoryTrackPoint::lon() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.lon)
  return lon_;
}
inline void AISHistoryTrackPoint::set_lon(double value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.lon)
}

// required double lat = 8;
inline bool AISHistoryTrackPoint::has_lat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AISHistoryTrackPoint::set_has_lat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AISHistoryTrackPoint::clear_has_lat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AISHistoryTrackPoint::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double AISHistoryTrackPoint::lat() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.lat)
  return lat_;
}
inline void AISHistoryTrackPoint::set_lat(double value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.lat)
}

// required float cog = 9;
inline bool AISHistoryTrackPoint::has_cog() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AISHistoryTrackPoint::set_has_cog() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AISHistoryTrackPoint::clear_has_cog() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AISHistoryTrackPoint::clear_cog() {
  cog_ = 0;
  clear_has_cog();
}
inline float AISHistoryTrackPoint::cog() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.cog)
  return cog_;
}
inline void AISHistoryTrackPoint::set_cog(float value) {
  set_has_cog();
  cog_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.cog)
}

// required float heading = 10;
inline bool AISHistoryTrackPoint::has_heading() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AISHistoryTrackPoint::set_has_heading() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AISHistoryTrackPoint::clear_has_heading() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AISHistoryTrackPoint::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float AISHistoryTrackPoint::heading() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.heading)
  return heading_;
}
inline void AISHistoryTrackPoint::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.heading)
}

// optional int32 cargoType = 11;
inline bool AISHistoryTrackPoint::has_cargotype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AISHistoryTrackPoint::set_has_cargotype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AISHistoryTrackPoint::clear_has_cargotype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AISHistoryTrackPoint::clear_cargotype() {
  cargotype_ = 0;
  clear_has_cargotype();
}
inline ::google::protobuf::int32 AISHistoryTrackPoint::cargotype() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.cargoType)
  return cargotype_;
}
inline void AISHistoryTrackPoint::set_cargotype(::google::protobuf::int32 value) {
  set_has_cargotype();
  cargotype_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.cargoType)
}

// required uint64 UTC = 12;
inline bool AISHistoryTrackPoint::has_utc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AISHistoryTrackPoint::set_has_utc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AISHistoryTrackPoint::clear_has_utc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AISHistoryTrackPoint::clear_utc() {
  utc_ = GOOGLE_ULONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::uint64 AISHistoryTrackPoint::utc() const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackPoint.UTC)
  return utc_;
}
inline void AISHistoryTrackPoint::set_utc(::google::protobuf::uint64 value) {
  set_has_utc();
  utc_ = value;
  // @@protoc_insertion_point(field_set:com.zhichenhaixin.proto.AISHistoryTrackPoint.UTC)
}

// -------------------------------------------------------------------

// AISHistoryTrackList

// repeated .com.zhichenhaixin.proto.AISHistoryTrackPoint aisData = 1;
inline int AISHistoryTrackList::aisdata_size() const {
  return aisdata_.size();
}
inline void AISHistoryTrackList::clear_aisdata() {
  aisdata_.Clear();
}
inline const ::com::zhichenhaixin::proto::AISHistoryTrackPoint& AISHistoryTrackList::aisdata(int index) const {
  // @@protoc_insertion_point(field_get:com.zhichenhaixin.proto.AISHistoryTrackList.aisData)
  return aisdata_.Get(index);
}
inline ::com::zhichenhaixin::proto::AISHistoryTrackPoint* AISHistoryTrackList::mutable_aisdata(int index) {
  // @@protoc_insertion_point(field_mutable:com.zhichenhaixin.proto.AISHistoryTrackList.aisData)
  return aisdata_.Mutable(index);
}
inline ::com::zhichenhaixin::proto::AISHistoryTrackPoint* AISHistoryTrackList::add_aisdata() {
  // @@protoc_insertion_point(field_add:com.zhichenhaixin.proto.AISHistoryTrackList.aisData)
  return aisdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISHistoryTrackPoint >&
AISHistoryTrackList::aisdata() const {
  // @@protoc_insertion_point(field_list:com.zhichenhaixin.proto.AISHistoryTrackList.aisData)
  return aisdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::zhichenhaixin::proto::AISHistoryTrackPoint >*
AISHistoryTrackList::mutable_aisdata() {
  // @@protoc_insertion_point(field_mutable_list:com.zhichenhaixin.proto.AISHistoryTrackList.aisData)
  return &aisdata_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace zhichenhaixin
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::zhichenhaixin::proto::EPFD> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::zhichenhaixin::proto::EPFD>() {
  return ::com::zhichenhaixin::proto::EPFD_descriptor();
}
template <> struct is_proto_enum< ::com::zhichenhaixin::proto::NAVI_STATUS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::zhichenhaixin::proto::NAVI_STATUS>() {
  return ::com::zhichenhaixin::proto::NAVI_STATUS_descriptor();
}
template <> struct is_proto_enum< ::com::zhichenhaixin::proto::ATON_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::zhichenhaixin::proto::ATON_TYPE>() {
  return ::com::zhichenhaixin::proto::ATON_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ZCHXAISVessel_2eproto__INCLUDED
